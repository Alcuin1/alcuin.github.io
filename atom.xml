<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jerek的code world</title>
  
  
  <link href="https://alcuin1.github.io/atom.xml" rel="self"/>
  
  <link href="https://alcuin1.github.io/"/>
  <updated>2024-07-02T15:08:02.015Z</updated>
  <id>https://alcuin1.github.io/</id>
  
  <author>
    <name>jerek</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Kafka生产者消息丢失问题复盘</title>
    <link href="https://alcuin1.github.io/2024/04/29/kafka%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98%E5%A4%8D%E7%9B%98/"/>
    <id>https://alcuin1.github.io/2024/04/29/kafka%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98%E5%A4%8D%E7%9B%98/</id>
    <published>2024-04-29T04:22:27.000Z</published>
    <updated>2024-07-02T15:08:02.015Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>kafka的生产者生产消息存在部分丢失，导致消费的时候对不上账，因为生产者是通过py调用的，所以查看kafka源码来确定问题根本原因。</p><h1 id="源码剖析"><a href="#源码剖析" class="headerlink" title="源码剖析"></a>源码剖析</h1><p>脱敏后的代码调用如下逻辑：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">send_msg</span>():</span><br><span class="line">    producer = KafkaProducer(bootstrap_servers=kafka_hosts)</span><br><span class="line">    msg = &#123;&#125;</span><br><span class="line">    msg[<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;xiaoming&quot;</span></span><br><span class="line">    msg[<span class="string">&quot;age&quot;</span>] = <span class="string">&quot;male&quot;</span></span><br><span class="line">    msg_send = json.dumps(msg)</span><br><span class="line">    producer.send(<span class="string">&#x27;topic&#x27;</span>, msg_send.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br></pre></td></tr></table></figure><p>py3.6中，查看kafka-&gt;producer-&gt;kafka.py中的send()函数源码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">send</span>(<span class="params">self, topic, value=<span class="literal">None</span>, key=<span class="literal">None</span>, partition=<span class="literal">None</span>, timestamp_ms=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="keyword">assert</span> value <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">or</span> self.config[<span class="string">&#x27;api_version&#x27;</span>] &gt;= (<span class="number">0</span>, <span class="number">8</span>, <span class="number">1</span>), (</span><br><span class="line">        <span class="string">&#x27;Null messages require kafka &gt;= 0.8.1&#x27;</span>)</span><br><span class="line">    <span class="keyword">assert</span> <span class="keyword">not</span> (value <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> key <span class="keyword">is</span> <span class="literal">None</span>), <span class="string">&#x27;Need at least one: key or value&#x27;</span></span><br><span class="line">    key_bytes = value_bytes = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># first make sure the metadata for the topic is</span></span><br><span class="line">        <span class="comment"># available</span></span><br><span class="line">        self._wait_on_metadata(topic, self.config[<span class="string">&#x27;max_block_ms&#x27;</span>] / <span class="number">1000.0</span>)</span><br><span class="line"></span><br><span class="line">        key_bytes = self._serialize(</span><br><span class="line">            self.config[<span class="string">&#x27;key_serializer&#x27;</span>],</span><br><span class="line">            topic, key)</span><br><span class="line">        value_bytes = self._serialize(</span><br><span class="line">            self.config[<span class="string">&#x27;value_serializer&#x27;</span>],</span><br><span class="line">            topic, value)</span><br><span class="line">        partition = self._partition(topic, partition, key, value,</span><br><span class="line">                                    key_bytes, value_bytes)</span><br><span class="line"></span><br><span class="line">        message_size = MessageSet.HEADER_SIZE + Message.HEADER_SIZE</span><br><span class="line">        <span class="keyword">if</span> key_bytes <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            message_size += <span class="built_in">len</span>(key_bytes)</span><br><span class="line">        <span class="keyword">if</span> value_bytes <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            message_size += <span class="built_in">len</span>(value_bytes)</span><br><span class="line">        self._ensure_valid_record_size(message_size)</span><br><span class="line"></span><br><span class="line">        tp = TopicPartition(topic, partition)</span><br><span class="line">        <span class="keyword">if</span> timestamp_ms <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            timestamp_ms = <span class="built_in">int</span>(time.time() * <span class="number">1000</span>)</span><br><span class="line">        log.debug(<span class="string">&quot;Sending (key=%r value=%r) to %s&quot;</span>, key, value, tp)</span><br><span class="line">        result = self._accumulator.append(tp, timestamp_ms,</span><br><span class="line">                                          key_bytes, value_bytes,</span><br><span class="line">                                          self.config[<span class="string">&#x27;max_block_ms&#x27;</span>])</span><br><span class="line">        future, batch_is_full, new_batch_created = result</span><br><span class="line">        <span class="keyword">if</span> batch_is_full <span class="keyword">or</span> new_batch_created:</span><br><span class="line">            log.debug(<span class="string">&quot;Waking up the sender since %s is either full or&quot;</span></span><br><span class="line">                       <span class="string">&quot; getting a new batch&quot;</span>, tp)</span><br><span class="line">            self._sender.wakeup()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> future</span><br><span class="line">        <span class="comment"># handling exceptions and record the errors;</span></span><br><span class="line">        <span class="comment"># for API exceptions return them in the future,</span></span><br><span class="line">        <span class="comment"># for other exceptions raise directly</span></span><br><span class="line">    <span class="keyword">except</span> Errors.KafkaTimeoutError:</span><br><span class="line">        <span class="keyword">raise</span></span><br><span class="line">    <span class="keyword">except</span> AssertionError:</span><br><span class="line">        <span class="keyword">raise</span></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        log.debug(<span class="string">&quot;Exception occurred during message send: %s&quot;</span>, e)</span><br><span class="line">        <span class="keyword">return</span> FutureRecordMetadata(</span><br><span class="line">            FutureProduceResult(TopicPartition(topic, partition)),</span><br><span class="line">            -<span class="number">1</span>, <span class="literal">None</span>, <span class="literal">None</span>,</span><br><span class="line">            <span class="built_in">len</span>(key_bytes) <span class="keyword">if</span> key_bytes <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">else</span> -<span class="number">1</span>,</span><br><span class="line">            <span class="built_in">len</span>(value_bytes) <span class="keyword">if</span> value_bytes <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">        ).failure(e)</span><br></pre></td></tr></table></figure><p>这里只截取除了部分重要源码。</p><p>从31行得出，发送的消息只是被append到了kafka的发送缓冲区accumulator中去，并没有立即发送。</p><p>34行返回了发送对象future</p><p><strong>从35行看出，其实待发送的消息可能会在发送缓冲区中停留一段时间，直到发送缓冲区填满发送或需要创建新的发送批次，发送线程才会被唤醒将其发送到Kafka集群中。</strong></p><p>因此，如果我们想要确保消息已经成功发送，可以使用Future.get()方法或注册回调函数或错误处理函数来处理发送结果。</p><p>Future.get()方法会等待消息发送完成，获取消息的元数据信息，比如主题、分区和偏移量等元数据信息。</p><p>但是Future.get()方法会阻塞当前线程，直到消息发送完成或引发异常。如果不想阻塞当前线程，可以使用Future.add_callback()方法或Future.add_errback()方法来注册回调函数或错误处理函数，来异步地处理发送结果。</p><p>出于业务背景的考虑，这里选择使用异步回调函数来处理发送结果。</p><p>那么如果我们想强制发送缓冲区内的消息而不是等待其满了再发送呢？</p><p>kafka提供了两个办法：flush()与close()</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">flush</span>(<span class="params">self, timeout=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Invoking this method makes all buffered records immediately available</span></span><br><span class="line"><span class="string">    to send (even if linger_ms is greater than 0) and blocks on the</span></span><br><span class="line"><span class="string">    completion of the requests associated with these records. The</span></span><br><span class="line"><span class="string">    post-condition of :meth:`~kafka.KafkaProducer.flush` is that any</span></span><br><span class="line"><span class="string">    previously sent record will have completed</span></span><br><span class="line"><span class="string">    (e.g. Future.is_done() == True). A request is considered completed when</span></span><br><span class="line"><span class="string">    either it is successfully acknowledged according to the &#x27;acks&#x27;</span></span><br><span class="line"><span class="string">    configuration for the producer, or it results in an error.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Other threads can continue sending messages while one thread is blocked</span></span><br><span class="line"><span class="string">    waiting for a flush call to complete; however, no guarantee is made</span></span><br><span class="line"><span class="string">    about the completion of messages sent after the flush call begins.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Arguments:</span></span><br><span class="line"><span class="string">        timeout (float, optional): timeout in seconds to wait for completion.</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">    Raises:</span></span><br><span class="line"><span class="string">        KafkaTimeoutError: failure to flush buffered records within the </span></span><br><span class="line"><span class="string">            provided timeout </span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    log.debug(<span class="string">&quot;Flushing accumulated records in producer.&quot;</span>)  <span class="comment"># trace</span></span><br><span class="line">    self._accumulator.begin_flush()</span><br><span class="line">    self._sender.wakeup()</span><br><span class="line">    self._accumulator.await_flush_completion(timeout=timeout)</span><br></pre></td></tr></table></figure><p>在主动调用flush()之后，会强制唤醒发送线程开始发送kafka消息</p><p>但是在close()函数中也有一段_sender线程优雅退出的逻辑：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">close</span>(<span class="params">self, timeout=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Close this producer.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Arguments:</span></span><br><span class="line"><span class="string">        timeout (float, optional): timeout in seconds to wait for completion.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># drop our atexit handler now to avoid leaks</span></span><br><span class="line">    self._unregister_cleanup()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">hasattr</span>(self, <span class="string">&#x27;_closed&#x27;</span>) <span class="keyword">or</span> self._closed:</span><br><span class="line">        log.info(<span class="string">&#x27;Kafka producer closed&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span> timeout <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="comment"># threading.TIMEOUT_MAX is available in Python3.3+</span></span><br><span class="line">        timeout = <span class="built_in">getattr</span>(threading, <span class="string">&#x27;TIMEOUT_MAX&#x27;</span>, <span class="number">999999999</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">getattr</span>(threading, <span class="string">&#x27;TIMEOUT_MAX&#x27;</span>, <span class="literal">False</span>):</span><br><span class="line">        <span class="keyword">assert</span> <span class="number">0</span> &lt;= timeout &lt;= <span class="built_in">getattr</span>(threading, <span class="string">&#x27;TIMEOUT_MAX&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">assert</span> timeout &gt;= <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    log.info(<span class="string">&quot;Closing the Kafka producer with %s secs timeout.&quot;</span>, timeout)</span><br><span class="line">    <span class="comment">#first_exception = AtomicReference() # this will keep track of the first encountered exception</span></span><br><span class="line">    invoked_from_callback = <span class="built_in">bool</span>(threading.current_thread() <span class="keyword">is</span> self._sender)</span><br><span class="line">    <span class="keyword">if</span> timeout &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">if</span> invoked_from_callback:</span><br><span class="line">            log.warning(<span class="string">&quot;Overriding close timeout %s secs to 0 in order to&quot;</span></span><br><span class="line">                        <span class="string">&quot; prevent useless blocking due to self-join. This&quot;</span></span><br><span class="line">                        <span class="string">&quot; means you have incorrectly invoked close with a&quot;</span></span><br><span class="line">                        <span class="string">&quot; non-zero timeout from the producer call-back.&quot;</span>,</span><br><span class="line">                        timeout)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># Try to close gracefully.</span></span><br><span class="line">            <span class="keyword">if</span> self._sender <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                self._sender.initiate_close()</span><br><span class="line">                self._sender.join(timeout)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> self._sender <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> self._sender.is_alive():</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;Proceeding to force close the producer since pending&quot;</span></span><br><span class="line">                 <span class="string">&quot; requests could not be completed within timeout %s.&quot;</span>,</span><br><span class="line">                 timeout)</span><br><span class="line">        self._sender.force_close()</span><br><span class="line">        <span class="comment"># Only join the sender thread when not calling from callback.</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> invoked_from_callback:</span><br><span class="line">            self._sender.join()</span><br><span class="line"></span><br><span class="line">    self._metrics.close()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        self.config[<span class="string">&#x27;key_serializer&#x27;</span>].close()</span><br><span class="line">    <span class="keyword">except</span> AttributeError:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        self.config[<span class="string">&#x27;value_serializer&#x27;</span>].close()</span><br><span class="line">    <span class="keyword">except</span> AttributeError:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    self._closed = <span class="literal">True</span></span><br><span class="line">    log.debug(<span class="string">&quot;The Kafka producer has closed.&quot;</span>)</span><br></pre></td></tr></table></figure><p>33行-36行：看出主要是调用initiate_close()函数和join(timeout)函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">initiate_close</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Start closing the sender (won&#x27;t complete until all data is sent).&quot;&quot;&quot;</span></span><br><span class="line">    self._running = <span class="literal">False</span></span><br><span class="line">    self._accumulator.close()</span><br><span class="line">    self.wakeup()</span><br></pre></td></tr></table></figure><p>initiate_close()函数会修改运行状态，关闭_accumulator，然后唤醒发送线程发送消息</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">join</span>(<span class="params">self, timeout=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Wait until the thread terminates.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    This blocks the calling thread until the thread whose join() method is</span></span><br><span class="line"><span class="string">    called terminates -- either normally or through an unhandled exception</span></span><br><span class="line"><span class="string">    or until the optional timeout occurs.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    When the timeout argument is present and not None, it should be a</span></span><br><span class="line"><span class="string">    floating point number specifying a timeout for the operation in seconds</span></span><br><span class="line"><span class="string">    (or fractions thereof). As join() always returns None, you must call</span></span><br><span class="line"><span class="string">    isAlive() after join() to decide whether a timeout happened -- if the</span></span><br><span class="line"><span class="string">    thread is still alive, the join() call timed out.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    When the timeout argument is not present or None, the operation will</span></span><br><span class="line"><span class="string">    block until the thread terminates.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    A thread can be join()ed many times.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    join() raises a RuntimeError if an attempt is made to join the current</span></span><br><span class="line"><span class="string">    thread as that would cause a deadlock. It is also an error to join() a</span></span><br><span class="line"><span class="string">    thread before it has been started and attempts to do so raises the same</span></span><br><span class="line"><span class="string">    exception.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> self._initialized:</span><br><span class="line">        <span class="keyword">raise</span> RuntimeError(<span class="string">&quot;Thread.__init__() not called&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> self._started.is_set():</span><br><span class="line">        <span class="keyword">raise</span> RuntimeError(<span class="string">&quot;cannot join thread before it is started&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> self <span class="keyword">is</span> current_thread():</span><br><span class="line">        <span class="keyword">raise</span> RuntimeError(<span class="string">&quot;cannot join current thread&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> timeout <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        self._wait_for_tstate_lock()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># the behavior of a negative timeout isn&#x27;t documented, but</span></span><br><span class="line">        <span class="comment"># historically .join(timeout=x) for x&lt;0 has acted as if timeout=0</span></span><br><span class="line">        self._wait_for_tstate_lock(timeout=<span class="built_in">max</span>(timeout, <span class="number">0</span>))</span><br></pre></td></tr></table></figure><p>join()会阻塞当前线程，直到发送线程完成所有未完成的消息发送操作或超时。如果发送线程在超时时间内完成了所有未完成的消息发送操作，则join()方法会返回None。如果发送线程在超时时间内没有完成所有未完成的消息发送操作，则join()方法会引发QueueFull异常。</p><p>在sender.py这个代码块中，_send线程在优雅退出时会被唤醒并且完成所有数据的发送，然后再进行关闭。</p><h1 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h1><p>1.添加producer.flush()或者producer.close()强制发送缓冲区内的kafka消息（更简单）</p><p>2.处理send返回的future对象调用get()方法之后的结果</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;kafka的生产者生产消息存在部分丢失，导致消费的时候对不上账，因为生产者是通过py调用的，所以查看kafka源码来确定问题根本原因。&lt;/p</summary>
      
    
    
    
    <category term="Kafka" scheme="https://alcuin1.github.io/categories/Kafka/"/>
    
    
    <category term="Kafka" scheme="https://alcuin1.github.io/tags/Kafka/"/>
    
  </entry>
  
  <entry>
    <title>go如何优雅关闭程序</title>
    <link href="https://alcuin1.github.io/2024/04/25/go%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%85%B3%E9%97%AD%E7%A8%8B%E5%BA%8F/"/>
    <id>https://alcuin1.github.io/2024/04/25/go%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%85%B3%E9%97%AD%E7%A8%8B%E5%BA%8F/</id>
    <published>2024-04-25T04:16:14.000Z</published>
    <updated>2024-07-02T15:08:02.014Z</updated>
    
    <content type="html"><![CDATA[<p>做后台开发的都知道，当我们需要对服务进行重启，例如升级发版、异常重启时，会面临到有新的请求在不断进来，同时当前可能还有正在处理的请求还未完成，如果此时直接对服务进行关闭重启，是有一定风险的。尤其是一些写操作，可能会造成数据丢失或损害。</p><p>正因如此我们应该等到请求都处理完成了才进行程序的退出，本文接下来就来介绍下在go语言中，针对http服务的场景如何进行优雅的程序退出。</p><p><strong>我们先用go实现一个简单的http服务。</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;io&quot;</span></span><br><span class="line"><span class="string">&quot;math/rand&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">msg := r.URL.Query().Get(<span class="string">&quot;msg&quot;</span>)</span><br><span class="line"><span class="comment">// 模拟处理一个耗时的请求</span></span><br><span class="line">delay := time.Duration(<span class="number">5</span>+rand.Intn(<span class="number">5</span>)) * time.Second <span class="comment">// 5-10 seconds.</span></span><br><span class="line"></span><br><span class="line">startedAt := time.Now()</span><br><span class="line">fmt.Println(<span class="string">&quot;req received, delay&quot;</span>, delay)</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;req completed, latency&quot;</span>, time.Since(startedAt))</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">time.Sleep(delay)</span><br><span class="line">w.WriteHeader(http.StatusOK)</span><br><span class="line">_, _ = io.WriteString(w, msg)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">mux := http.NewServeMux()</span><br><span class="line">mux.HandleFunc(<span class="string">&quot;/process&quot;</span>, handler)</span><br><span class="line"></span><br><span class="line">srv := &amp;http.Server&#123;Addr: <span class="string">&quot;:8080&quot;</span>, Handler: mux&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;server started, addr:%s&quot;</span>, srv.Addr)</span><br><span class="line"><span class="keyword">if</span> err := srv.ListenAndServe(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;could not start server, error:%v&quot;</span>, err)</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们实现了一个模拟耗时请求的handler，如果此时我们直接关闭服务的话，这个耗时的请求将没法得到完整的处理。既然如此，我们需要先让程序知道，接下来程序要退出了，但是你先别着急退出。</p><p>那怎么知道呢，其实操作系统会在此时向程序发送一个SIGTERM的信号，那我们只需要让程序捕获这个信号就可以了。</p><p>来看下实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">mux := http.NewServeMux()</span><br><span class="line">mux.HandleFunc(<span class="string">&quot;/process&quot;</span>, handler)</span><br><span class="line"></span><br><span class="line">srv := &amp;http.Server&#123;Addr: <span class="string">&quot;:8080&quot;</span>, Handler: mux&#125;</span><br><span class="line">serverError := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">error</span>, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;server started, addr&quot;</span>, srv.Addr)</span><br><span class="line"><span class="keyword">if</span> err := srv.ListenAndServe(); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> !errors.Is(err, http.ErrServerClosed) &#123;</span><br><span class="line">serverError &lt;- err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">watchedSignals := []os.Signal&#123;syscall.SIGINT, syscall.SIGTERM&#125;</span><br><span class="line">shutdownListener := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal, <span class="number">1</span>)</span><br><span class="line">signal.Notify(shutdownListener, watchedSignals...)</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;listen shutdown request&quot;</span>)</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> err := &lt;-serverError:</span><br><span class="line">fmt.Println(<span class="string">&quot;listen and serve error&quot;</span>, err)</span><br><span class="line"><span class="keyword">case</span> sig := &lt;-shutdownListener:</span><br><span class="line">fmt.Println(<span class="string">&quot;\nreceived shutdown request signal&quot;</span>, sig)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面main函数代码中，可以看到几点变化：</p><ol><li>我们通过 <code>signal.Notify()</code> 监听了两个程序退出信号，当接收到信号后则会被发送到 <code>shutdownListener</code> 管道中<ul><li><strong>SIGINT</strong>：当你在终端按下ctrl+c时，则会触发这个信号</li><li><strong>SIGTERM</strong>：当我们给程序发送kill或者killall指令时，则会触发这个信号</li></ul></li><li>执行 <code>srv.ListenAndServe()</code> 后，程序是会被阻塞在这行代码中的。为了避免后续的信号监测的代码得到执行，我们需要将其放到协程中执行。</li><li>我们将 <code>srv.ListenAndServe()</code> 出错的退出处理 <code>os.Exit(1)</code> 去掉了，也通过管道通知的方式，统一在最外层的主协程中统一来处理。需要注意，这里不处理服务关闭这个错误（<strong>ErrServerClosed</strong>），后面会解释。</li></ol><p>到这里我们已经实现了通知我们的服务程序要退出这个信号了，接下来我们要让程序真正的优雅退出。有两点要求：</p><ol><li>让服务不再接收新的请求。</li><li>尽可能晚的退出程序，让正在处理中的请求尽可能的都处理完。</li></ol><p>go的http网络库中提供了 <code>Shutdown</code> 方法来拒绝新的请求，而已经接收到的请求并不会被关闭，而是会等待其处理完成再关闭。同时 <code>Serve</code> 、 <code>ListenAndServe</code> 和 <code>ListenAndServeTLS</code> 会立即返回 <strong>ErrServerClosed</strong>错误，因此我们不能在接收到这个错误后关闭程序。</p><p>来看下代码实现</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gracefulShutdown</span><span class="params">(srv *http.Server)</span></span> &#123;</span><br><span class="line">shutdownTime := <span class="number">10</span> * time.Second</span><br><span class="line">fmt.Println(<span class="string">&quot;shutting down server, wait&quot;</span>, shutdownTime)</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">&quot;server shutdown gracefully&quot;</span>)</span><br><span class="line"></span><br><span class="line">ctx, cancel := context.WithTimeout(context.Background(), shutdownTime)</span><br><span class="line"><span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := srv.Shutdown(ctx); err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;shut down server fail&quot;</span>, err)</span><br><span class="line"><span class="keyword">if</span> errors.Is(err, context.DeadlineExceeded) &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;executing forced shutdown&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err := srv.Close(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;server close failed&quot;</span>, <span class="string">&quot;error&quot;</span>, err)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;forced shutdown completed&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">... <span class="comment">// 这部分代码参考上面实现</span></span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;listen shutdown request&quot;</span>)</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> err := &lt;-serverError:</span><br><span class="line">fmt.Println(<span class="string">&quot;listen and serve error&quot;</span>, err)</span><br><span class="line"><span class="keyword">case</span> sig := &lt;-shutdownListener:</span><br><span class="line">fmt.Println(<span class="string">&quot;\nreceived shutdown request signal&quot;</span>, sig)</span><br><span class="line">gracefulShutdown(srv)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们实现了一个优雅退出的函数 <code>gracefulShutdown()</code> ，代码不难理解，需要注意Shutdown方法需要接收一个context对象，这里我们定义了一个10秒超时的context，如果超过这个时间请求都还没完成处理，则会采用强制退出的方式，主要是为了避免程序长时间等待无法退出，当年你也可以选择传入一个没有超时的context（例如直接传入context.Background()）。</p><p>至此我们已经实现了一个程序优雅退出的功能了，当然你还可以继续往 <code>gracefulShutdown()</code> 中添加其他退出前需要完成的操作，例如数据库和消息队列等连接断开，上报程序关闭日志等等，这些我们就不赘述了。</p><p>接下来贴出完整的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;context&quot;</span></span><br><span class="line"><span class="string">&quot;errors&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;io&quot;</span></span><br><span class="line"><span class="string">&quot;math/rand&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line"><span class="string">&quot;os/signal&quot;</span></span><br><span class="line"><span class="string">&quot;syscall&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">msg := r.URL.Query().Get(<span class="string">&quot;msg&quot;</span>)</span><br><span class="line"><span class="comment">// 模拟处理一个耗时的请求</span></span><br><span class="line">delay := time.Duration(<span class="number">5</span>+rand.Intn(<span class="number">5</span>)) * time.Second <span class="comment">// 5-10 seconds.</span></span><br><span class="line"></span><br><span class="line">startedAt := time.Now()</span><br><span class="line">fmt.Println(<span class="string">&quot;req received, delay&quot;</span>, delay)</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;req completed, latency&quot;</span>, time.Since(startedAt))</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">time.Sleep(delay)</span><br><span class="line">w.WriteHeader(http.StatusOK)</span><br><span class="line">_, _ = io.WriteString(w, msg)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gracefulShutdown</span><span class="params">(srv *http.Server)</span></span> &#123;</span><br><span class="line">shutdownTime := <span class="number">10</span> * time.Second</span><br><span class="line">fmt.Println(<span class="string">&quot;shutting down server, wait&quot;</span>, shutdownTime)</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">&quot;server shutdown gracefully&quot;</span>)</span><br><span class="line"></span><br><span class="line">ctx, cancel := context.WithTimeout(context.Background(), shutdownTime)</span><br><span class="line"><span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := srv.Shutdown(ctx); err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;shut down server fail&quot;</span>, err)</span><br><span class="line"><span class="keyword">if</span> errors.Is(err, context.DeadlineExceeded) &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;executing forced shutdown&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err := srv.Close(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;server close failed&quot;</span>, <span class="string">&quot;error&quot;</span>, err)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;forced shutdown completed&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">mux := http.NewServeMux()</span><br><span class="line">mux.HandleFunc(<span class="string">&quot;/process&quot;</span>, handler)</span><br><span class="line"></span><br><span class="line">srv := &amp;http.Server&#123;Addr: <span class="string">&quot;:8080&quot;</span>, Handler: mux&#125;</span><br><span class="line">serverError := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">error</span>, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;server started, addr&quot;</span>, srv.Addr)</span><br><span class="line"><span class="keyword">if</span> err := srv.ListenAndServe(); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> !errors.Is(err, http.ErrServerClosed) &#123;</span><br><span class="line">serverError &lt;- err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">watchedSignals := []os.Signal&#123;syscall.SIGINT, syscall.SIGTERM&#125;</span><br><span class="line">shutdownListener := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal, <span class="number">1</span>)</span><br><span class="line">signal.Notify(shutdownListener, watchedSignals...)</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;listen shutdown request&quot;</span>)</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> err := &lt;-serverError:</span><br><span class="line">fmt.Println(<span class="string">&quot;listen and serve error&quot;</span>, err)</span><br><span class="line"><span class="keyword">case</span> sig := &lt;-shutdownListener:</span><br><span class="line">fmt.Println(<span class="string">&quot;\nreceived shutdown request signal&quot;</span>, sig)</span><br><span class="line">gracefulShutdown(srv)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;做后台开发的都知道，当我们需要对服务进行重启，例如升级发版、异常重启时，会面临到有新的请求在不断进来，同时当前可能还有正在处理的请求还未完成，如果此时直接对服务进行关闭重启，是有一定风险的。尤其是一些写操作，可能会造成数据丢失或损害。&lt;/p&gt;
&lt;p&gt;正因如此我们应该等到请求</summary>
      
    
    
    
    <category term="go" scheme="https://alcuin1.github.io/categories/go/"/>
    
    
    <category term="go" scheme="https://alcuin1.github.io/tags/go/"/>
    
    <category term="RPC" scheme="https://alcuin1.github.io/tags/RPC/"/>
    
  </entry>
  
  <entry>
    <title>Go context原理与实践</title>
    <link href="https://alcuin1.github.io/2024/04/10/Go%20context%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/"/>
    <id>https://alcuin1.github.io/2024/04/10/Go%20context%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/</id>
    <published>2024-04-10T03:04:11.000Z</published>
    <updated>2024-07-02T15:08:02.014Z</updated>
    
    <content type="html"><![CDATA[<h1 id="context-Context"><a href="#context-Context" class="headerlink" title="context.Context"></a>context.Context</h1><p>上下文 <a href="https://draveness.me/golang/tree/context.Context"><code>context.Context</code></a> Go 语言中用来设置截止日期、同步信号，传递请求相关值的结构体。上下文与 Goroutine 有比较密切的关系，是 Go 语言中独特的设计，在其他编程语言中我们很少见到类似的概念。</p><p><a href="https://draveness.me/golang/tree/context.Context"><code>context.Context</code></a> 是 Go 语言在 1.7 版本中引入标准库的接口<a href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-context/#fn:1">1</a>，该接口定义了四个需要实现的方法，其中包括：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Context <span class="keyword">interface</span> &#123;</span><br><span class="line">Deadline() (deadline time.Time, ok <span class="type">bool</span>)</span><br><span class="line">Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">Err() <span class="type">error</span></span><br><span class="line">Value(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p><code>Deadline</code> — 返回 <a href="https://draveness.me/golang/tree/context.Context"><code>context.Context</code></a> 被取消的时间，也就是context截止日期；</p></li><li><p><code>Done</code> — 返回一个 Channel，这个 Channel 会在当前工作完成或者上下文被取消后关闭，多次调用 <code>Done</code> 方法会返回同一个 Channel；</p><p> <img src="https://telegraph-image-5gr.pages.dev/file/9bf67e6bd2158fd98556d.png" alt="value"></p><p> <img src="https://telegraph-image-5gr.pages.dev/file/d2690cce133da0415dabc.png" alt="done"></p></li><li><p>Err — 返回<code>context.Context</code>结束的原因，它只会在Done方法对应的 Channel 关闭时返回非空的值；</p><ol><li>如果 <a href="https://draveness.me/golang/tree/context.Context"><code>context.Context</code></a> 被取消，会返回 <code>Canceled</code> 错误；</li><li>如果 <a href="https://draveness.me/golang/tree/context.Context"><code>context.Context</code></a> 超时，会返回 <code>DeadlineExceeded</code> 错误；</li></ol></li><li><p><code>Value</code> — 从 <a href="https://draveness.me/golang/tree/context.Context"><code>context.Context</code></a> 中获取键对应的值，对于同一个上下文来说，多次调用 <code>Value</code> 并传入相同的 <code>Key</code> 会返回相同的结果，该方法可以用来传递请求特定的数据；</p></li></ol><p><img src="https://telegraph-image-5gr.pages.dev/file/91f1a3c076ccb1e3c1fba.png" alt="value"></p><p><a href="https://github.com/golang/go/tree/master/src/context"><code>context</code></a> 包中提供的 <a href="https://draveness.me/golang/tree/context.Background"><code>context.Background</code></a>、<a href="https://draveness.me/golang/tree/context.TODO"><code>context.TODO</code></a>、<a href="https://draveness.me/golang/tree/context.WithDeadline"><code>context.WithDeadline</code></a> 和 <a href="https://draveness.me/golang/tree/context.WithValue"><code>context.WithValue</code></a> 函数会返回实现该接口的私有结构体，我们会在后面详细介绍它们。</p><h1 id="设计原理"><a href="#设计原理" class="headerlink" title="设计原理"></a>设计原理</h1><p>在 Goroutine 构成的树形结构中对信号进行同步以减少计算资源的浪费是 <a href="https://draveness.me/golang/tree/context.Context"><code>context.Context</code></a> 的最大作用。Go 服务的每一个请求都是通过单独的 Goroutine 处理的<a href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-context/#fn:2">2</a>，HTTP&#x2F;RPC 请求的处理器会启动新的 Goroutine 访问数据库和其他服务。</p><p>如下图所示，我们可能会创建多个 Goroutine 来处理一次请求，而 <a href="https://draveness.me/golang/tree/context.Context"><code>context.Context</code></a> 的作用是在不同 Goroutine 之间同步请求特定数据、取消信号以及处理请求的截止日期。</p><p><img src="https://telegraph-image-5gr.pages.dev/file/83d32c9e2364f3a30140b.png" alt="context usgae"></p><p>第一个创建 Context 的 goroutine 被称为 root 节点：root 节点负责创建一个实现 Context 接口的具体对象，并将该对象作为参数传递至新拉起的 goroutine 作为其上下文。下游 goroutine 继续封装该对象并以此类推向下传递。Context 可以安全的被多个 goroutine 使用。<strong>开发者可以把一个 Context 传递给任意多个 goroutine 然后 cancel 这个 context 的时候就能够通知到所有的 goroutine。</strong></p><h1 id="四种实现"><a href="#四种实现" class="headerlink" title="四种实现"></a>四种实现</h1><p><code>emptyCtx</code>:空的context，可用作根结点或者占位节点</p><p><code>cancelCtx</code>:具有cancel函数的context，可以取消</p><p><code>timerCtx</code>:在cancelCtx基础上，增加定时器和截止时间来实现定时取消</p><p><code>valueCtx</code>: 可以存储键值对，比如常见的request_id，trace_id，用户信息等等，对于跟踪和调试分布式系统中的请求非常有用</p><h1 id="六个方法"><a href="#六个方法" class="headerlink" title="六个方法"></a>六个方法</h1><ul><li><p><code>Background()</code>返回emptyCtx作为根结点</p></li><li><p><code>TODO()</code>返回emptyCtx用户占位</p></li></ul><p><img src="https://telegraph-image-5gr.pages.dev/file/1abe7f51a00aa83e2e871.png" alt="TODO()和Background()"></p><ul><li><p><code>WithCancel()返回可取消的context</code></p></li><li><p><code>WithDeadline()</code>返回在到达截止时间会取消的context</p></li><li><p><code>WithTimeout()</code>返回一段时间后会超时取消的context</p></li><li><p><code>WithValue()</code>返回绑定了键值对的context</p><p>  <img src="https://telegraph-image-5gr.pages.dev/file/8563ba53252d5aa8bd6e5.png" alt="withValue()"></p></li></ul><h1 id="并发安全性"><a href="#并发安全性" class="headerlink" title="并发安全性"></a>并发安全性</h1><p>关于并发安全性，<code>context</code>包确保<code>Context</code>对象在并发场景下是安全的。这意味着你可以在多个goroutine中安全地传递和使用<code>Context</code>对象，而不需要额外的同步机制。<code>Context</code>的并发安全性主要通过以下几个方面实现：</p><ol><li>不可变性：<code>Context</code>对象是不可变的。当你使用<code>context.WithValue</code>创建一个新的<code>Context</code>时，原始<code>Context</code>不会被修改。这样可以确保在并发场景下，不同的goroutine看到的<code>Context</code>值是一致的。</li><li>原子操作：<code>Context</code>的某些操作（如添加值、取消信号等）是通过原子操作实现的，这确保了在并发场景下的正确性。</li><li>链式调用：<code>Context</code>支持链式调用，即一个<code>Context</code>可以基于另一个<code>Context</code>创建。这种设计有助于在并发场景下保持<code>Context</code>的一致性。</li></ol><p>然而，需要注意的是，虽然<code>Context</code>对象本身是并发安全的，但存储在其中的值（value）的并发安全性取决于值的类型和访问方式。如果存储的值是可变的数据结构（如map），并且多个goroutine同时访问和修改这些值，那么你需要确保对这些值的访问是同步的，以避免数据竞争和不一致的问题。</p><p>总之，<code>context.WithValue</code>创建的<code>Context</code>对象本身是并发安全的，但存储在其中的值的并发安全性需要根据具体情况进行处理。</p><h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><h2 id="1-控制请求的超时"><a href="#1-控制请求的超时" class="headerlink" title="1.控制请求的超时"></a><strong>1.控制请求的超时</strong></h2><p>在处理网络请求或其他可能需要长时间运行的操作时，可以使用<code>context</code>来设置一个超时时间。如果操作在超时时间内未完成，可以通过<code>context</code>取消该操作。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestContextTimeOut</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">ctx, cancel := context.WithTimeout(context.Background(), <span class="number">3</span>*time.Second)</span><br><span class="line"><span class="keyword">defer</span> cancel()</span><br><span class="line">result := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">time.Sleep(<span class="number">3</span> * time.Second) <span class="comment">// 模拟长时间运行的操作</span></span><br><span class="line">result &lt;- <span class="number">42</span></span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">fmt.Println(<span class="string">&quot;Operation timed out&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> res := &lt;-result:</span><br><span class="line">fmt.Println(<span class="string">&quot;Operation completed with result:&quot;</span>, res)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 Operation timed out  </span></span><br><span class="line"><span class="comment">// 因为ctx 2秒就超时，模拟运行了3秒， 如果ctx改成3秒超时，输出 Operation completed with result: 42</span></span><br></pre></td></tr></table></figure><h2 id="2-取消正在进行的操作"><a href="#2-取消正在进行的操作" class="headerlink" title="2.取消正在进行的操作"></a><strong>2.取消正在进行的操作</strong></h2><p>除了超时，还可以通过调用<code>context</code>的<code>cancel</code>函数来主动取消正在进行的操作。这在用户取消操作或服务降级时非常有用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestContextCancel</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">                fmt.Println(<span class="string">&quot;Operation cancelled&quot;</span>)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="comment">// 执行操作...</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="comment">// 在某个时刻取消操作</span></span><br><span class="line">    cancel()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-传递请求范围的元数据"><a href="#3-传递请求范围的元数据" class="headerlink" title="3.传递请求范围的元数据"></a><strong>3.传递请求范围的元数据</strong></h2><p><code>context</code>可以用于在不同的goroutine之间传递请求ID、trace_id等信息，这对于跟踪和调试分布式系统中的请求非常有用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestContextValue</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">ctx := context.WithValue(context.Background(), <span class="string">&quot;requestID&quot;</span>, <span class="string">&quot;12345&quot;</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">        requestID := ctx.Value(<span class="string">&quot;requestID&quot;</span>).(<span class="type">string</span>)</span><br><span class="line">        fmt.Println(<span class="string">&quot;Processing request:&quot;</span>, requestID)</span><br><span class="line">    &#125;(ctx)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-控制并发操作"><a href="#4-控制并发操作" class="headerlink" title="4.控制并发操作"></a><strong>4.控制并发操作</strong></h2><p>在并发编程中，可以使用<code>context</code>来控制一组goroutine的执行。例如，可以使用<code>context</code>来等待一组goroutine完成，或者通知它们停止执行。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestContextConcurrency</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(id <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">fmt.Println(<span class="string">&quot;Goroutine&quot;</span>, id, <span class="string">&quot;cancelled&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">default</span>: <span class="comment">// 执行操作...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;(i)</span><br><span class="line">&#125;</span><br><span class="line">cancel() <span class="comment">// 在某个时刻取消所有goroutine</span></span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">Goroutine <span class="number">4</span> cancelled</span><br><span class="line">Goroutine <span class="number">0</span> cancelled</span><br><span class="line">Goroutine <span class="number">1</span> cancelled</span><br><span class="line">Goroutine <span class="number">2</span> cancelled</span><br><span class="line">Goroutine <span class="number">3</span> cancelled</span><br></pre></td></tr></table></figure><h1 id="常用习惯"><a href="#常用习惯" class="headerlink" title="常用习惯"></a>常用习惯</h1><p>1.context放到结构体内，还是作为函数的第一个参数来使用这主要取决于具体的使用场景和设计模式。</p><p>在Go语言中，<code>context</code>包提供了一种跨API和goroutine传递请求范围数据、取消信号以及截止时间的方法。关于是否将<code>context</code>放入结构体内部，还是作为函数的第一个参数使用，这主要取决于具体的使用场景和设计模式。</p><p>以下是一些考虑因素和建议：</p><ol><li><strong>函数的可测试性</strong>：将<code>context</code>作为函数的第一个参数，可以更容易地对函数进行单元测试。你可以为测试创建一个模拟的<code>context</code>，而不需要依赖外部状态或全局变量。</li><li><strong>代码的可读性和清晰度</strong>：将<code>context</code>显式地作为参数传递，有助于提高代码的可读性和清晰度。它明确表明了这个函数依赖于<code>context</code>，而不是依赖于某个隐式的全局状态。</li><li><strong>并发安全性</strong>：由于<code>context</code>是并发安全的，将其作为参数传递不会引入额外的并发问题。相反，如果你将<code>context</code>嵌入到结构体中，并在多个goroutine中共享该结构体，你可能需要额外的同步机制来确保并发安全。</li><li><strong>避免过度封装</strong>：将<code>context</code>作为参数传递，而不是将其隐藏在一个结构体内部，有助于避免过度封装。这使得函数的接口更加简洁，也更容易理解和使用。</li><li><strong>灵活性</strong>：通过将<code>context</code>作为参数传递，你可以在不同的调用点传递不同的<code>context</code>实例，从而实现更细粒度的控制。例如，你可以在一个调用点传递一个带有超时设置的<code>context</code>，而在另一个调用点传递一个没有超时的<code>context</code>。</li></ol><p>但在某些情况下，将<code>context</code>嵌入到结构体中可能是合理的。例如，当你的结构体表示一个长期运行的服务或组件，并且需要在多个方法之间共享<code>context</code>时，将其嵌入到结构体中可能更方便。</p><p>总之，在决定是否将<code>context</code>放入结构体内部时，应权衡各种因素，并根据具体的应用场景和设计目标做出决策。在大多数情况下，将<code>context</code>作为函数的第一个参数使用是一种简单、清晰且灵活的做法。</p><p>2.不要传递一个nil的context，考虑使用context.TODO()或者context.Background()</p><p>3.最好不要将函数的参数塞到context中，context应存储请求范围内共同的数据</p><p>4.同一个context可能被传递到多个goroutine中，但它是并不是完全并发安全的（详见上述并发安全分析）</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-context/">https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-context/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;context-Context&quot;&gt;&lt;a href=&quot;#context-Context&quot; class=&quot;headerlink&quot; title=&quot;context.Context&quot;&gt;&lt;/a&gt;context.Context&lt;/h1&gt;&lt;p&gt;上下文 &lt;a href=&quot;https</summary>
      
    
    
    
    <category term="go" scheme="https://alcuin1.github.io/categories/go/"/>
    
    
    <category term="go" scheme="https://alcuin1.github.io/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>Go反射</title>
    <link href="https://alcuin1.github.io/2024/03/10/go%E5%8F%8D%E5%B0%84/"/>
    <id>https://alcuin1.github.io/2024/03/10/go%E5%8F%8D%E5%B0%84/</id>
    <published>2024-03-10T03:30:05.000Z</published>
    <updated>2024-07-02T15:08:02.014Z</updated>
    
    <content type="html"><![CDATA[<h1 id="go反射"><a href="#go反射" class="headerlink" title="go反射"></a>go反射</h1><p>在Go语言中，反射（reflection）是一种强大的机制，它允许程序在运行时检查类型信息、获取和修改变量的值。</p><h2 id="1-两个核心"><a href="#1-两个核心" class="headerlink" title="1.两个核心"></a>1.两个核心</h2><ul><li><p>reflect.Value</p><p>  用于操作值，部分值可以被反射修改</p></li><li><p>reflect.Type</p><p>  用于操作类信息，类信息是只能读取</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TestReflect 反射基础</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestReflect</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> num <span class="type">int</span> = <span class="number">42</span></span><br><span class="line"><span class="keyword">var</span> str <span class="type">string</span> = <span class="string">&quot;Hello, reflect!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取变量的类型</span></span><br><span class="line">fmt.Println(<span class="string">&quot;Type of num:&quot;</span>, reflect.TypeOf(num)) <span class="comment">// Type of num: int</span></span><br><span class="line">fmt.Println(<span class="string">&quot;Type of str:&quot;</span>, reflect.TypeOf(str)) <span class="comment">// Type of str: string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取变量的值</span></span><br><span class="line">fmt.Println(<span class="string">&quot;Value of num:&quot;</span>, reflect.ValueOf(num).Int())    <span class="comment">// Value of num: 42</span></span><br><span class="line">fmt.Println(<span class="string">&quot;Value of str:&quot;</span>, reflect.ValueOf(str).String()) <span class="comment">// Value of str: Hello, reflect!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>reflect.Type可以通过reflect.Value得到，但是反过来不行。</p><h3 id="reflect-Type-Kind"><a href="#reflect-Type-Kind" class="headerlink" title="reflect.Type Kind"></a>reflect.Type Kind</h3><p>Kind是一个枚举值，用来判断操作的对应类型，比如指针、数组、切片等等，如果调用的不对，它就只panic。</p><h3 id="反射遍历切片和映射"><a href="#反射遍历切片和映射" class="headerlink" title="反射遍历切片和映射"></a>反射遍历切片和映射</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 反射遍历切片和映射</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestReflectSliceAndMap</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">slice := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">m := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;<span class="string">&quot;one&quot;</span>: <span class="number">1</span>, <span class="string">&quot;two&quot;</span>: <span class="number">2</span>, <span class="string">&quot;three&quot;</span>: <span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历切片 使用reflect.ValueOf()获取切片或映射的反射值对象</span></span><br><span class="line">sliceVal := reflect.ValueOf(slice) </span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; sliceVal.Len(); i++ &#123;</span><br><span class="line">        <span class="comment">// 使用Len()和Index()方法遍历元素。</span></span><br><span class="line">fmt.Println(<span class="string">&quot;Slice element:&quot;</span>, sliceVal.Index(i).Int())</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 遍历映射</span></span><br><span class="line">mapVal := reflect.ValueOf(m)</span><br><span class="line">    <span class="comment">// 使用MapKeys()和MapIndex()方法遍历键值对</span></span><br><span class="line"><span class="keyword">for</span> _, key := <span class="keyword">range</span> mapVal.MapKeys() &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;Map key: %v, value: %v\n&quot;</span>, key.String(), mapVal.MapIndex(key).Int())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="修改结构体的值"><a href="#修改结构体的值" class="headerlink" title="修改结构体的值"></a>修改结构体的值</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="type">string</span></span><br><span class="line">Age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TestReflectSet 反射修改</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestReflectSet</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">p := Person&#123;Name: <span class="string">&quot;Alice&quot;</span>, Age: <span class="number">30</span>&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;反射修改前&quot;</span>, p) <span class="comment">// &#123;Bob 35&#125;</span></span><br><span class="line"><span class="comment">// 获取结构体的反射值对象 使用reflect.ValueOf()获取结构体的指针，然后调用Elem()获取指针指向的元素。</span></span><br><span class="line">val := reflect.ValueOf(&amp;p).Elem() </span><br><span class="line"><span class="comment">// 获取结构体字段的反射值对象并修改结构体字段的值</span></span><br><span class="line">nameField := val.FieldByName(<span class="string">&quot;Name&quot;</span>)</span><br><span class="line">    <span class="comment">// 在修改字段值之前，需要检查字段是否有效且可设置</span></span><br><span class="line"><span class="keyword">if</span> nameField.IsValid() &amp;&amp; nameField.CanSet() &#123;</span><br><span class="line">nameField.SetString(<span class="string">&quot;Bob&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">ageField := val.FieldByName(<span class="string">&quot;Age&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> ageField.IsValid() &amp;&amp; ageField.CanSet() &#123;</span><br><span class="line">ageField.SetInt(<span class="number">35</span>)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;反射修改后&quot;</span>, p) <span class="comment">// &#123;Bob 35&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-通过TDD来进行测试写逻辑"><a href="#3-通过TDD来进行测试写逻辑" class="headerlink" title="3.通过TDD来进行测试写逻辑"></a>3.通过TDD来进行测试写逻辑</h2><p>首先确定要支持通过结构体，结构体指针与多重结构体指针获取结构体内容的三种情况</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> reflect</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;reflect&quot;</span></span><br><span class="line"><span class="string">&quot;testing&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestIterateFields</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">u1 := &amp;User&#123;<span class="string">&quot;Tom&quot;</span>&#125;</span><br><span class="line"><span class="keyword">type</span> args <span class="keyword">struct</span> &#123;</span><br><span class="line">val any</span><br><span class="line">&#125;</span><br><span class="line">tests := []<span class="keyword">struct</span> &#123;</span><br><span class="line">name    <span class="type">string</span></span><br><span class="line">args    args</span><br><span class="line">want    <span class="keyword">map</span>[<span class="type">string</span>]any</span><br><span class="line">wantErr <span class="type">bool</span></span><br><span class="line">&#125;&#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> Add test cases.</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;user&quot;</span>,</span><br><span class="line">args&#123;</span><br><span class="line">User&#123;<span class="string">&quot;Tom&quot;</span>&#125;,</span><br><span class="line">&#125;,</span><br><span class="line"><span class="keyword">map</span>[<span class="type">string</span>]any&#123;<span class="string">&quot;Name&quot;</span>: <span class="string">&quot;Tom&quot;</span>&#125;,</span><br><span class="line"><span class="literal">false</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;支持user pointer&quot;</span>,</span><br><span class="line">args&#123;</span><br><span class="line">&amp;User&#123;<span class="string">&quot;Tom&quot;</span>&#125;,</span><br><span class="line">&#125;,</span><br><span class="line"><span class="keyword">map</span>[<span class="type">string</span>]any&#123;<span class="string">&quot;Name&quot;</span>: <span class="string">&quot;Tom&quot;</span>&#125;,</span><br><span class="line"><span class="literal">false</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;支持多重user pointer&quot;</span>,</span><br><span class="line">args&#123;</span><br><span class="line">&amp;u1,</span><br><span class="line">&#125;,</span><br><span class="line"><span class="keyword">map</span>[<span class="type">string</span>]any&#123;<span class="string">&quot;Name&quot;</span>: <span class="string">&quot;Tom&quot;</span>&#125;,</span><br><span class="line"><span class="literal">false</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, tt := <span class="keyword">range</span> tests &#123;</span><br><span class="line">t.Run(tt.name, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">got, err := IterateFields(tt.args.val)</span><br><span class="line"><span class="keyword">if</span> (err != <span class="literal">nil</span>) != tt.wantErr &#123;</span><br><span class="line">t.Errorf(<span class="string">&quot;IterateFields() error = %v, wantErr %v&quot;</span>, err, tt.wantErr)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> !reflect.DeepEqual(got, tt.want) &#123;</span><br><span class="line">t.Errorf(<span class="string">&quot;IterateFields() got = %v, want %v&quot;</span>, got, tt.want)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>开始编写代码，注释很详细，就不再一一解释了。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reflect.go</span></span><br><span class="line"><span class="keyword">package</span> reflect</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;errors&quot;</span></span><br><span class="line"><span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// User 用户</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="type">string</span></span><br><span class="line"><span class="comment">//Age  int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// IterateFields 反射</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IterateFields</span><span class="params">(val any)</span></span> (<span class="keyword">map</span>[<span class="type">string</span>]any, <span class="type">error</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> val == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;val is nil&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">refValue := reflect.ValueOf(val)</span><br><span class="line">typ := reflect.TypeOf(val)      <span class="comment">// 是可以通过上述valueOf()获取的，反之不可以</span></span><br><span class="line"><span class="keyword">for</span> typ.Kind() == reflect.Ptr &#123; <span class="comment">// 如果是指针类型，需要for循环去取最终指向的对象</span></span><br><span class="line">typ = typ.Elem()</span><br><span class="line">refValue = refValue.Elem()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取Field数量 NumField returns a struct type&#x27;s field count. It panics if the type&#x27;s Kind is not Struct.</span></span><br><span class="line">numField := typ.NumField()</span><br><span class="line">res := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]any, numField)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; numField; i++ &#123;</span><br><span class="line">fdType := typ.Field(i)</span><br><span class="line">res[fdType.Name] = refValue.Field(i).Interface() <span class="comment">// Interface returns v&#x27;s current value as an interface&#123;&#125;.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="4-一些细节"><a href="#4-一些细节" class="headerlink" title="4.一些细节"></a>4.一些细节</h2><p>反射是Go语言中一个非常强大的工具，但在使用时也需要格外小心，以避免引入不必要的复杂性和潜在的错误。因此使用反射时有一些需要注意的知识点和陷阱：</p><h3 id="1-性能开销"><a href="#1-性能开销" class="headerlink" title="1.性能开销"></a><strong>1.性能开销</strong></h3><p>反射操作通常比直接操作要慢得多，因为它们需要在运行时进行类型检查和方法调用。因此，应避免在性能敏感的代码中使用反射。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TestReflectPerformance 反射性能</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestReflectPerformance</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> num <span class="type">int</span></span><br><span class="line">start := time.Now()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++ &#123;</span><br><span class="line">_ = reflect.TypeOf(num)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;反射耗时:&quot;</span>, time.Since(start))</span><br><span class="line"></span><br><span class="line">start = time.Now()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++ &#123;</span><br><span class="line">_ = typeof(num) <span class="comment">// 假设typeof是获取类型的普通函数（golang中没有该函数，一般通过类型判断和类型断言，或者%T打印</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;普通类型检查耗时:&quot;</span>, time.Since(start))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-类型安全性"><a href="#2-类型安全性" class="headerlink" title="2.类型安全性"></a><strong>2.类型安全性</strong></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num <span class="type">int</span></span><br><span class="line">rv := reflect.ValueOf(num)</span><br><span class="line"><span class="comment">// rv.SetInt(42) // 这会引发panic，因为num是不可寻址的</span></span><br></pre></td></tr></table></figure><p>反射会绕过编译时的类型检查，这可能导致运行时错误。在使用反射之前，应确保代码逻辑正确无误，以避免潜在的panic。</p><h3 id="3-并发安全问题"><a href="#3-并发安全问题" class="headerlink" title="3.并发安全问题"></a>3.并发安全问题</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SafeCounter <span class="keyword">struct</span> &#123;</span><br><span class="line">mu    sync.Mutex</span><br><span class="line">value <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *SafeCounter)</span></span> Increment() &#123;</span><br><span class="line">c.mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> c.mu.Unlock()</span><br><span class="line">c.value++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *SafeCounter)</span></span> GetValue() <span class="type">int</span> &#123;</span><br><span class="line">c.mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> c.mu.Unlock()</span><br><span class="line"><span class="keyword">return</span> c.value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TestReflectConcurrency 反射并发</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestReflectConcurrency</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">counter := SafeCounter&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用反射获取并修改值（非并发安全）</span></span><br><span class="line">val := reflect.ValueOf(&amp;counter).Elem()</span><br><span class="line">valueField := val.FieldByName(<span class="string">&quot;value&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> valueField.IsValid() &amp;&amp; valueField.CanSet() &#123;</span><br><span class="line">valueField.SetInt(valueField.Int() + <span class="number">1</span>) <span class="comment">// 可能会导致竞态条件</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确的方式是使用并发安全的方法</span></span><br><span class="line">counter.Increment()</span><br><span class="line">fmt.Println(counter.GetValue())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-反射的类型安全性"><a href="#4-反射的类型安全性" class="headerlink" title="4.反射的类型安全性"></a>4.反射的类型安全性</h3><p>反射可能会导致运行时错误，因为它绕过了编译时类型检查。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TestReflectSafety 反射安全性</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestReflectSafety</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> num <span class="type">int</span></span><br><span class="line">val := reflect.ValueOf(num)</span><br><span class="line"><span class="comment">// rv.SetInt(42) // 这会引发panic，因为num是不可寻址的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 而是应该如下写法：</span></span><br><span class="line">cnt := <span class="number">12</span></span><br><span class="line">val = reflect.ValueOf(&amp;cnt).Elem()</span><br><span class="line"><span class="keyword">if</span> val.IsValid() &amp;&amp; val.CanSet() &#123;</span><br><span class="line">val.SetInt(<span class="number">42</span>)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(cnt)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-不可导出字段和方法"><a href="#5-不可导出字段和方法" class="headerlink" title="5.不可导出字段和方法"></a>5.不可导出字段和方法</h3><p>反射无法访问结构体中未导出的字段（小写开头）或方法。如果需要访问这些成员，必须通过导出的接口或其他方式来实现。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> myStruct <span class="keyword">struct</span> &#123;</span><br><span class="line">Exported   <span class="type">string</span> <span class="comment">// 可导出字段</span></span><br><span class="line">unexported <span class="type">string</span> <span class="comment">// 未导出字段</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ms *myStruct)</span></span> ExportedMethod() &#123; fmt.Println(<span class="string">&quot;ExportedMethod&quot;</span>) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ms *myStruct)</span></span> ExportedMethodWithPara(name <span class="type">string</span>, age <span class="type">int</span>) &#123;</span><br><span class="line">fmt.Println(name, age, <span class="string">&quot;ExportedMethod&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ms *myStruct)</span></span> unexportedMethod() &#123; fmt.Println(<span class="string">&quot;unexportedMethod&quot;</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TestReflectSafety 反射未导出</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestReflectUnexported</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">ms := &amp;myStruct&#123;<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;World&quot;</span>&#125;</span><br><span class="line">rv := reflect.ValueOf(ms).Elem()</span><br><span class="line">fmt.Println(rv.FieldByName(<span class="string">&quot;Exported&quot;</span>))</span><br><span class="line"></span><br><span class="line">val := reflect.ValueOf(ms)</span><br><span class="line">val.MethodByName(<span class="string">&quot;ExportedMethod&quot;</span>).Call(<span class="literal">nil</span>)</span><br><span class="line">val.MethodByName(<span class="string">&quot;ExportedMethodWithPara&quot;</span>).</span><br><span class="line">Call([]reflect.Value&#123;reflect.ValueOf(<span class="string">&quot;Tom&quot;</span>), reflect.ValueOf(<span class="number">10</span>)&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//fmt.Println(rv.FieldByName(&quot;unexported&quot;))     // 这会引发panic，因为字段未导出</span></span><br><span class="line"><span class="comment">//rv.MethodByName(&quot;unexportedMethod&quot;).Call(nil) // 同样会引发panic，因为方法未导出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-空指针异常"><a href="#6-空指针异常" class="headerlink" title="6.空指针异常"></a>6.空指针异常</h3><p>当使用反射来获取或设置值为nil的指针指向的数据时，会导致运行时panic。在使用反射之前，应检查变量是否为nil。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TestReflectPointer 处理空指针</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestReflectPointer</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> p *Person</span><br><span class="line"><span class="comment">// 获取指针的反射值对象</span></span><br><span class="line">val := reflect.ValueOf(p)</span><br><span class="line"><span class="comment">// 检查指针是否为nil</span></span><br><span class="line"><span class="keyword">if</span> val.IsNil() &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Pointer is nil&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Pointer is not nil&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-切片、映射和指针的特殊情况"><a href="#7-切片、映射和指针的特殊情况" class="headerlink" title="7.切片、映射和指针的特殊情况"></a>7.切片、映射和指针的特殊情况</h3><p>在使用反射处理切片、映射和指针时，需要注意它们的特殊行为。例如，对切片的反射操作可能会影响底层数组，而对映射的反射操作需要先检查键是否存在。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TestReflectOtherTypes 反射其他类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestReflectOtherTypes</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">slice := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">m := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;<span class="string">&quot;one&quot;</span>: <span class="number">1</span>&#125;</span><br><span class="line">p := &amp;slice[<span class="number">2</span>]</span><br><span class="line"><span class="comment">// 切片</span></span><br><span class="line">fmt.Println(reflect.ValueOf(slice).Index(<span class="number">1</span>).Int()) <span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 映射</span></span><br><span class="line">k := reflect.ValueOf(<span class="string">&quot;one&quot;</span>)</span><br><span class="line">fmt.Println(reflect.ValueOf(m).MapIndex(k).Int()) <span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 指针</span></span><br><span class="line">fmt.Println(reflect.ValueOf(p).Elem().Int()) <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-类型断言"><a href="#8-类型断言" class="headerlink" title="8.类型断言"></a>8.类型断言</h3><p>在使用反射时，可能需要使用类型断言来将<code>reflect.Value</code>转换回原始类型，以便进行特定类型的操作。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TestReflectAssertion 反射类型断言</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestReflectAssertion</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> num <span class="type">int</span> = <span class="number">42</span></span><br><span class="line">rv := reflect.ValueOf(num)</span><br><span class="line"><span class="keyword">if</span> rv.Kind() == reflect.Int &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Value is an int:&quot;</span>, rv.Int())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-保持代码可读性和维护性"><a href="#9-保持代码可读性和维护性" class="headerlink" title="9.保持代码可读性和维护性"></a>9.保持代码可读性和维护性</h3><p>过度使用反射会使代码变得难以理解和维护。应谨慎使用反射，并尽可能保持代码的清晰和简洁。</p><p>尽量使用接口和类型断言代替反射，只在必要时使用反射。对于常见的反射任务，考虑封装成函数或库，以提高代码的可重用性。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;go反射&quot;&gt;&lt;a href=&quot;#go反射&quot; class=&quot;headerlink&quot; title=&quot;go反射&quot;&gt;&lt;/a&gt;go反射&lt;/h1&gt;&lt;p&gt;在Go语言中，反射（reflection）是一种强大的机制，它允许程序在运行时检查类型信息、获取和修改变量的值。&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="go" scheme="https://alcuin1.github.io/categories/go/"/>
    
    
    <category term="go" scheme="https://alcuin1.github.io/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>服务上云学习笔记(1)</title>
    <link href="https://alcuin1.github.io/2024/03/10/%E6%9C%8D%E5%8A%A1%E4%B8%8A%E4%BA%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/"/>
    <id>https://alcuin1.github.io/2024/03/10/%E6%9C%8D%E5%8A%A1%E4%B8%8A%E4%BA%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/</id>
    <published>2024-03-10T02:09:09.000Z</published>
    <updated>2024-07-02T15:08:02.015Z</updated>
    
    <content type="html"><![CDATA[<h1 id="服务上云学习"><a href="#服务上云学习" class="headerlink" title="服务上云学习"></a>服务上云学习</h1><p>最近学习了一门关于服务上云的课程。后台服务上云需要关注地方有很多：高可用、高并发、安全性、可运维性等等。</p><p>但是由于是公司内部课程，不太方便举出一些实际案例，因此仅仅是罗列一些概念等等</p><h2 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h2><h3 id="诱因"><a href="#诱因" class="headerlink" title="诱因"></a>诱因</h3><ul><li>内部：代码问题、配置问题、性能问题</li><li>外部：网络故障、机房故障（电力、制冷）、服务器故障、基础组件故障、依赖服务故障、运维操作失误、恶意攻击</li></ul><h3 id="快速恢复"><a href="#快速恢复" class="headerlink" title="快速恢复"></a>快速恢复</h3><ul><li><p>指标</p><p>  整体服务健康度：MTBF平均无故障时间、MTTR平均故障恢复时间</p><p>  容灾恢复能力：RPO（realtime  point objective）、RTO(realtime time objective)</p></li><li><p>设计原则</p><p>  避免错误（提升MTBF）、控制影响（缩小影响范围）、快速恢复（降低MTTR）</p></li><li><p>三大要素</p><p>  接入层、逻辑层、数据层</p></li><li><p>措施</p><p>  同城冷备：多IDC环境，数据定期同步或强同步，DNS或GSLB或者CLB切换</p><p>  同城双活：不同区间内网互通，两地三中心、三地五中心、每个区承担2&#x2F;3流量、同时做好自动切换流量</p></li></ul><h3 id="避免错误"><a href="#避免错误" class="headerlink" title="避免错误"></a>避免错误</h3><ul><li><p>异常处理：防止错误请求、防止重复请求、幂等重复请求、异常中断处理</p></li><li><p>失败处理：失败立即重试、记录失败后置处理、直接失败返回异常、忽略失败继续流程</p></li><li><p>并发冲突：做好并发错误处理，以及并发场景的考虑</p><p>  完成实现目标：标准化配置、多环境、自动化来实现部署，出错可第一时间回滚。</p></li></ul><p><a href="https://mp.weixin.qq.com/s/nGtC5lBX_Iaj57HIdXq3Qg">B站202107案例</a></p><h3 id="控制影响"><a href="#控制影响" class="headerlink" title="控制影响"></a>控制影响</h3><ul><li><p>前置操作：缓存、限流、降级、错误处理</p></li><li><p>资源冗余：接入层构建DNS返回ip地址，缓存本地，递归查询；基础设施（自然灾害、供电、光缆、水冷、IDC网络，IEP&#x2F;BGP、CLB+CVM弹性收缩、DB层主从主备分片、块存储、k8s、分布式db、负载均衡架构、应用层集群横向扩展）</p></li><li><p>故障隔离：容灾心跳故障迁移</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;服务上云学习&quot;&gt;&lt;a href=&quot;#服务上云学习&quot; class=&quot;headerlink&quot; title=&quot;服务上云学习&quot;&gt;&lt;/a&gt;服务上云学习&lt;/h1&gt;&lt;p&gt;最近学习了一门关于服务上云的课程。后台服务上云需要关注地方有很多：高可用、高并发、安全性、可运维性等等。&lt;/</summary>
      
    
    
    
    <category term="后台" scheme="https://alcuin1.github.io/categories/%E5%90%8E%E5%8F%B0/"/>
    
    
    <category term="上云" scheme="https://alcuin1.github.io/tags/%E4%B8%8A%E4%BA%91/"/>
    
  </entry>
  
  <entry>
    <title>一些思考</title>
    <link href="https://alcuin1.github.io/2024/02/02/%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/"/>
    <id>https://alcuin1.github.io/2024/02/02/%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/</id>
    <published>2024-02-02T04:32:48.000Z</published>
    <updated>2024-06-27T17:32:52.492Z</updated>
    
    <content type="html"><![CDATA[<h2 id="面试要点：如何判断面试者的真实水平？"><a href="#面试要点：如何判断面试者的真实水平？" class="headerlink" title="面试要点：如何判断面试者的真实水平？"></a>面试要点：如何判断面试者的真实水平？</h2><p>首先，从源头抓起。简历筛选的过程要保障候选人和岗位的强匹配性，面试过程我们可以用简历中的<strong>项目过程</strong>、用到的<strong>关键技术</strong>、如何解决最棘手的技术问题，来考察项目真实性，对相关技术栈的系统性使用，以及是否真正独立解决过实际问题等方面。</p><p>在面试沟通时，我们尽量用领域内的<strong>开放性问题</strong>，比如前端领域里的，当时某个项目为什么用 React？如果不是自己选的，那你现在觉得好处和缺点分别是什么等等；也可以根据他当时解决棘手问题的方法去深挖<strong>技术细节</strong>。在这个过程中尽量让候选人多讲，当然也要把控节奏，不能让候选人漫无目的地发散。通过聆听候选人的讲述，还是比较容易判断候选人是否真实做过该项目，以及相关技术深度和广度的，另外还可以了解候选人的技术热情和学习能力。</p><p>从结构化校对来看，我会从学习、成长背景，实际工作、项目经历，主导设计了什么系统或者解决了什么技术难点几个方面来考察岗位相关的技术栈水平，中间的提问可以结合当前自己公司遇到的一些困难来举例，不一定要很精准的回答，主要是设想一下如果他入职后来解决这些困难，我们是否比较放心。</p><p>多数情况下，我们需要根据岗位的性质做一些取舍。比如有些岗位的特性决定了技术能力非常重要或者市场上能达到技术要求的候选人非常少，那我们就得接受难以管理的候选人（例如傲慢，难以沟通，懒散等等）的高管理成本。</p><p>像业务研发团队可能对技术深度要求没那么高，但对技术广度的要求比较高，因此在工作中，个性上是要能够接受长时间重复工作且任劳任怨的人。如果工作时的业务价值导向不明显，想要极具技术创新性，那么在一个稳定输出的业务技术团队就有可能“破坏”团队文化，把业务价值第一的团队带偏到以技术创新为主。</p><p>针对招聘时的人才观，不能要求全才，只要能匹配团队，能给公司产出价值的就可以。</p><p>如果从技术管理者的视角来看，其必须掌控自己团队的技术方向，能明确技术发展方向，同时也清楚知道自己团队当前的技术短板和优势，这样才能对预期的候选人画像心里有数，而不是临场来确定我到底要什么样的人才。</p><h2 id="如何看待技术、业务、能力呢？"><a href="#如何看待技术、业务、能力呢？" class="headerlink" title="如何看待技术、业务、能力呢？"></a>如何看待技术、业务、能力呢？</h2><p>业务 &amp; 产品侧、技术改造、紧急的线上问题、效能提升几个方面</p><p>在业务驱动的项目中，特别是一些业务比较复杂的下项目，比如，金融系统、银行系统、财务系统、清结算系统、物流系统等，我们还可以积累一些业务壁垒。如果你之前的工作都是从事偏向业务系统的开发，靠技术只能面到阿里 P7 这个层级。如果想面到阿里的 P8、P9，靠的就不仅仅只是技术了，还需要对某个业务的深入积累。实际上，很多领导之所以能做领导，不是技术牛逼，而是对业务熟悉。</p><p><strong>不过，并不是所有的业务系统开发，业务都有足够的复杂度，可以让你积累竞争壁垒。对于技术没有太大挑战，业务也不复杂的项目开发，我们可以多积累自己的能力。</strong></p><p>这里所说的能力，指的是成事能力、解决问题的能力。实际上，很多问题的解决，即便是技术问题的解决，靠的都不是技术，而是一个人最基本的解决问题的能力。这其中就包括分析总结能力、逻辑思维能力、沟通协调能力、自我驱动能力等等。</p><p>实际上，比起短短的 1 个小时的面试，我个人也更倾向于通过学历、项目（项目经历是否有技术难度）、履历（是否有知名公司的工作经历、以及职位高低），这些过去的能够证明能力的经历来判断一个候选人。特别是对于一些中高端的岗位，好的学历、项目、履历基本上有碾压性的优势。我自己做面试官多年，基本上在看完候选人的简历之后，对符不符合我们招聘要求，心里就有个八九不离十的判断了。在面试开始的前 10 分钟，我基本上已经决定要不要录用他了。后面的面试只是为了进一步证实自己刚刚的决定而已。</p><p>如果说<strong>技术、业务、能力</strong>是程序员的立命之本，它们决定了你能不能在职场这场比赛中胜出，那<strong>学历、项目、履历</strong>就是入场门票，决定了你可以选择哪个比赛赛道，是 Google、Facebook，还是 BAT，又或者是完全不知名的小公司。</p><p>所以，在夯实技术、业务、能力的同时，你也要学会“面向简历打工”“面向跳槽打工”，提前做一些职业规划，把自己的履历弄好看点，比如，学历太低的就去考个好点的学历，在公司内部努力去选择做一些有技术含量的项目，跳槽去一些知名点的互联网公司等等。</p><h3 id="不要让职场软技能成为短板"><a href="#不要让职场软技能成为短板" class="headerlink" title="不要让职场软技能成为短板"></a>不要让职场软技能成为短板</h3><p>总的来讲，要想职场混得好，一些必须的沟通、协作、总结汇报等软技能还是不能忽视的，当然，我也不是推崇，纯靠“耍手段”上位。我只是觉得，这方面起码不能成为你的短板，不要让这些非技术、非能力的因素，阻碍了你职场的发展</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>极客时间-技术领导力实战 招兵买马：如何判断候选人与岗位的匹配程度？</p><p>极客时间-技术领导力实战 从任务分配角度来看管理</p><p>极客时间-设计模式之美-加餐8 程序员怎么才能让自己走得更高、更远？</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;面试要点：如何判断面试者的真实水平？&quot;&gt;&lt;a href=&quot;#面试要点：如何判断面试者的真实水平？&quot; class=&quot;headerlink&quot; title=&quot;面试要点：如何判断面试者的真实水平？&quot;&gt;&lt;/a&gt;面试要点：如何判断面试者的真实水平？&lt;/h2&gt;&lt;p&gt;首先，从源头</summary>
      
    
    
    
    <category term="复盘" scheme="https://alcuin1.github.io/categories/%E5%A4%8D%E7%9B%98/"/>
    
    
    <category term="复盘" scheme="https://alcuin1.github.io/tags/%E5%A4%8D%E7%9B%98/"/>
    
  </entry>
  
  <entry>
    <title>深圳gopher大会</title>
    <link href="https://alcuin1.github.io/2024/01/07/%E6%B7%B1%E5%9C%B3gopher%E5%A4%A7%E4%BC%9A/"/>
    <id>https://alcuin1.github.io/2024/01/07/%E6%B7%B1%E5%9C%B3gopher%E5%A4%A7%E4%BC%9A/</id>
    <published>2024-01-07T12:27:59.000Z</published>
    <updated>2024-07-02T15:08:02.015Z</updated>
    
    <content type="html"><![CDATA[<p>昨天去参加了深圳的GopherDay，工作之后第一次去参加这种专业性的技术交流会还是很兴奋的，大家在自我介绍的时候，也都能感受到里面有很多的大佬，虽然很多东西都听不太懂，但是也算是见见世面。（给我推荐这个大会的同事告诉我，深圳很少举办这些，基本都是在北京&#x2F;上海</p><p><img src="https://telegraph-image-5gr.pages.dev/file/922e76ad113a59aaf3e5d.png" alt="大会分享简介"></p><p>里面其实能听明白一些的，主要还是下午cgo这一场次了，不过到那会儿也已经比较累了，一天的分享下来感觉并不比上班的强度低（太菜了）。</p><p><img src="https://telegraph-image-5gr.pages.dev/file/4f93564c9b4186c2abce4.png"></p><p>里面主要是讲解了C语言与Go语言的底层原理知识，包括GMP调度模型，Go编译，Go asm，C compiler</p><p><img src="https://telegraph-image-5gr.pages.dev/file/2232fd15f47e8488f6ced.png" alt="C调go"></p><p><img src="https://telegraph-image-5gr.pages.dev/file/9a6434650a8c0d3d51f7d.png" alt="golang内存管理方式"></p><p><img src="https://telegraph-image-5gr.pages.dev/file/65acc7e49eec69e79e72f.png" alt="10x优化"></p><p><img src="https://telegraph-image-5gr.pages.dev/file/afbff8bda5e0efca12534.png" alt="折腾一年多"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;昨天去参加了深圳的GopherDay，工作之后第一次去参加这种专业性的技术交流会还是很兴奋的，大家在自我介绍的时候，也都能感受到里面有很多的大佬，虽然很多东西都听不太懂，但是也算是见见世面。（给我推荐这个大会的同事告诉我，深圳很少举办这些，基本都是在北京&amp;#x2F;上海&lt;/</summary>
      
    
    
    
    <category term="go" scheme="https://alcuin1.github.io/categories/go/"/>
    
    
    <category term="go" scheme="https://alcuin1.github.io/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>markdown基本语法</title>
    <link href="https://alcuin1.github.io/2024/01/05/markdown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
    <id>https://alcuin1.github.io/2024/01/05/markdown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</id>
    <published>2024-01-05T05:32:01.000Z</published>
    <updated>2024-07-02T15:08:02.015Z</updated>
    
    <content type="html"><![CDATA[<p>首先上<a href="https://markdown.com.cn/basic-syntax/">官方参考链接</a></p><p>其次简单做一下笔记，记录一下常用的语法。</p><h1 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h1><p>通过控制 # 的数量来表明标题的级 一个就是一级，记得在#后面加个空格，其次就是<h1>与</h1> 也可以表示</p><h1 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h1><p>通过<p>与</p>即可</p><p>不要用空格（spaces）或制表符（ tabs）缩进段落。</p><h1 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h1><p>选中以后按Command+B即可（mac），或者直接用**即可</p><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><blockquote><p>用&gt;即可</p></blockquote><h1 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h1><p>有序列表 数字+小数点</p><p>1. </p><h1 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h1><ul><li>段横岗-加上空格即可</li></ul><h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><p>通过<a href=""></a>的方式即可，[]里面放标题，()里面放链接</p><p>使用&lt;&gt;，里面放上链接，可以直接转换成可点击的链接</p><h1 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h1><p>写文档，图片是少不了的</p><p>相较于链接的<a href=""></a>格式，在前面加一个英文的感叹号即可!，[]里面放标题，()里面放链接</p><p>ps：最好能够有自己的图床，这样就会方便分享到网上</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>其他的知识，有用到就再补充吧！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;首先上&lt;a href=&quot;https://markdown.com.cn/basic-syntax/&quot;&gt;官方参考链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;其次简单做一下笔记，记录一下常用的语法。&lt;/p&gt;
&lt;h1 id=&quot;标题&quot;&gt;&lt;a href=&quot;#标题&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="Markdown" scheme="https://alcuin1.github.io/categories/Markdown/"/>
    
    
    <category term="Markdown" scheme="https://alcuin1.github.io/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title>git常用命令</title>
    <link href="https://alcuin1.github.io/2024/01/05/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>https://alcuin1.github.io/2024/01/05/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</id>
    <published>2024-01-05T05:21:46.000Z</published>
    <updated>2024-07-08T15:33:26.275Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://telegraph-image-5gr.pages.dev/file/8d9fb7979c933de38b530.jpg" alt="tidy desk"></p><h1 id="git常用命令"><a href="#git常用命令" class="headerlink" title="git常用命令"></a>git常用命令</h1><h2 id="基本操作流程"><a href="#基本操作流程" class="headerlink" title="基本操作流程"></a>基本操作流程</h2><p><img src="https://telegraph-image-5gr.pages.dev/file/eb5fa975f8bb365a078e9.png" alt="git"></p><p>常用命令以及开发顺序如下：</p><p><code>git clone git链接, git init  , git pull, git branch -b newBranch，git status, git add ., git commit -m &quot;your commit message&quot;</code></p><p><code>git push --set-upstream origin feat_new,  git push, git merge master</code></p><h2 id="配置config信息"><a href="#配置config信息" class="headerlink" title="配置config信息"></a>配置config信息</h2><p><code>git config (--global) user.name &quot;xxx&quot; git config (--global) user.email &quot;xx@163.com&quot;</code></p><h2 id="gitignore"><a href="#gitignore" class="headerlink" title=".gitignore"></a>.gitignore</h2><p>在任何当前工作的 Git 仓库中，每个文件都是这样的：</p><ul><li><strong>追踪的（tracked）</strong>- 这些是 Git 所知道的所有文件或目录。这些是新添加（用 <code>git add</code> 添加）和提交（用 <code>git commit</code> 提交）到主仓库的文件和目录。</li><li><strong>未被追踪的（untracked）</strong> - 这些是在工作目录中创建的，但还没有被暂存（或用 <code>git add</code> 命令添加）的任何新文件或目录。</li><li><strong>被忽略的（ignored）</strong> - 这些是 Git 知道的要全部排除、忽略或在 Git 仓库中不需要注意的所有文件或目录。本质上，这是一种告诉 Git 哪些未被追踪的文件应该保持不被追踪并且永远不会被提交的方法。</li></ul><p>所有被忽略的文件都会被保存在一个 <code>.gitignore</code> 文件中。</p><p><code>.gitignore</code> 文件是一个纯文本文件，包含了项目中所有指定的文件和文件夹的列表，这些文件和文件夹是 Git 应该忽略和不追踪的。</p><p>在 <code>.gitignore</code> 中，你可以通过提及特定文件或文件夹的名称或模式来告诉 Git 只忽略一个文件或一个文件夹。你也可以用同样的方法告诉 Git 忽略多个文件或文件夹。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># 名字前面有点（.）的文件默认是隐藏的。</span><br><span class="line"># 忽略根目录下的text.txt文件</span><br><span class="line">/text.txt</span><br><span class="line"># 忽略一个位于根目录下的 test 目录中的 text.txt 文件</span><br><span class="line">/test/text.txt</span><br><span class="line"># 或者</span><br><span class="line">test/text.txt</span><br><span class="line"># 忽略位于项目中任何地方的具有该特定名称的所有文件 text.txt 文件</span><br><span class="line">text.txt</span><br><span class="line"># 要忽略整个目录及其所有内容，你需要包括目录的名称，并在最后加上斜线 /：</span><br><span class="line">test/</span><br><span class="line"># 匹配任何名字带有 test 的文件和目录</span><br><span class="line">test</span><br><span class="line"># 忽略所有名称以 img 开头的文件和目录</span><br><span class="line">img*</span><br><span class="line"># 忽略所有以 .md 文件扩展名结尾的 markdown 文件</span><br><span class="line">*.md</span><br><span class="line"># 假设忽略所有以 .md 结尾的文件，但不希望 Git 忽略一个 README.md 文件</span><br><span class="line"># 忽略所有 .md 文件</span><br><span class="line">.md</span><br><span class="line"># 不忽略 README.md 文件</span><br><span class="line">!README.md</span><br><span class="line"></span><br><span class="line"># 给 .gitignore 添加 .env 文件</span><br><span class="line">echo &quot;.env&quot; &gt;&gt; .gitignore</span><br></pre></td></tr></table></figure><h3 id="不生效怎么办？"><a href="#不生效怎么办？" class="headerlink" title="不生效怎么办？"></a>不生效怎么办？</h3><p>修改.gitignore之后不生效？</p><p>原因：只能忽略那些原来没有被track的文件，如果某些文件已经被纳入了版本管理中，修改.gitignore是无效的。</p><p>解决方法：删除本地缓存，改变为未track状态，再commit</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git rm -r --cached .</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;update .gitignore&quot;</span><br></pre></td></tr></table></figure><h2 id="修改上一次提交"><a href="#修改上一次提交" class="headerlink" title="修改上一次提交"></a>修改上一次提交</h2><p>有时候我们提交完了才发现漏掉了几个文件没有添加，或者提交信息写错了。 此时，可以运行带有 <code>--amend</code> 选项的提交命令来重新提交：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m &#x27;initial commit&#x27;</span><br><span class="line">$ git add forgotten_file</span><br><span class="line">$ git commit --amend</span><br><span class="line">$ git push -f (强制提交)</span><br></pre></td></tr></table></figure><p>最终你只会有一个提交——第二次提交将代替第一次提交的结果</p><h2 id="Cherry-pick"><a href="#Cherry-pick" class="headerlink" title="Cherry-pick"></a>Cherry-pick</h2><p>挑选其他分支的几个commitid，然后切换到目标分支</p><p>git checkout target_branch</p><p>复制commitid</p><p>git cherry-pick commitid 1 commitid2 … </p><p>然后目标分支会出现如下新的提交记录，按照commit1id1 和commitid 2顺序进行先后提交</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">自动合并 main.go</span><br><span class="line">[master_tmp f29a5a5] 2</span><br><span class="line"> Date: Tue Jan 9 10:40:27 2024 +0800</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line">[master_tmp 36ddf9f] 1</span><br><span class="line"> Date: Tue Jan 9 10:58:09 2024 +0800</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure><h2 id="Rebase"><a href="#Rebase" class="headerlink" title="Rebase"></a>Rebase</h2><p><a href="http://jartto.wang/2018/12/11/git-rebase/">参考</a></p><p>我们在第一时间基于master分支开出新的分支feature1进行开发</p><p>但是后面呢其他同事也是同样基于同样的master分支拉出一条新的分支feature2开发，但是比你先合并到master，这时候如果我们直接merge，git是不会允许的，因为当前的master分支已经不再是”当年的”master分支了，我们可以选择merge（不符主题），也可以选择<strong>rebase</strong>。 rebase操作如下：</p><p>1.首先确保在当前的开发分支 </p><p>git checkout feature1</p><p>2.rebase操作</p><p>git rebase master</p><p>这条命令会将feature2的所有修改rebase到你的feature1分支上，feature2的修改都会出现在你的git log提交记录里面，然后正常开发测试结束之后可以直接merge到master分支，master分支的提交记录也会是一条线性提交记录（merge操作的话master分支上并不是线性提交记录）</p><h3 id="rebase-–onto"><a href="#rebase-–onto" class="headerlink" title="rebase –onto"></a>rebase –onto</h3><p>如果需要将一个分支的几个提交，迁移到另外一个分支应该如何做呢？(所有的提交最好不要有冲突，最好不要出现修改同一处地方)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">branch1</span><br><span class="line">commit 8f18ef28</span><br><span class="line">4</span><br><span class="line">commit 4b437925</span><br><span class="line">3</span><br><span class="line">commit 20d8159e</span><br><span class="line">2</span><br><span class="line">commit 2fd34b83</span><br><span class="line">1</span><br><span class="line"></span><br><span class="line">branch2</span><br><span class="line">commit 55ab6cd6</span><br><span class="line">xxxxxx(这不重要)</span><br></pre></td></tr></table></figure><p>移动newbranch上的某几个commitid到最新的commitid到某个分支上 </p><p>语法：git rebase –onto target_branch commitid1 commitid2 (前开后闭，即不包含commitid1到commitid2)，下面一行例子就是移动提交3和4到目标分支</p><p>git rebase –onto master_tmp 20d8159e 8f18ef28 </p><p>现在会出现分离，然后生成新的分离分支：8f50335</p><p>也可以将其保存到新的分支，合并其分支到目标分支也可 git checkout -b newBranch </p><p>切换到目标分支，并且合并新的分支过来即可</p><p>git checkout master_tmp </p><p>git merge 8f50335</p><p>结果就是：</p><p>branch2</p><p>commit 8f18ef28<br>4<br>commit 4b437925<br>3</p><p>commit 55ab6cd6<br>xxxxxx(这不重要)</p><h3 id="rebase-i-怎么用？"><a href="#rebase-i-怎么用？" class="headerlink" title="rebase -i 怎么用？"></a>rebase -i 怎么用？</h3><p>git rebase -i &lt;起始commit id&gt;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># 命令:</span><br><span class="line"># p, pick &lt;提交&gt; = 使用提交</span><br><span class="line"># r, reword &lt;提交&gt; = 使用提交，但编辑提交说明</span><br><span class="line"># e, edit &lt;提交&gt; = 使用提交，但停止以便修补提交</span><br><span class="line"># s, squash &lt;提交&gt; = 使用提交，但挤压到前一个提交</span><br><span class="line"># f, fixup [-C | -c] &lt;提交&gt; = 类似于 &quot;squash&quot;，但只保留前一个提交</span><br><span class="line">#                    的提交说明，除非使用了 -C 参数，此情况下则只</span><br><span class="line">#                    保留本提交说明。使用 -c 和 -C 类似，但会打开</span><br><span class="line">#                    编辑器修改提交说明</span><br><span class="line"># x, exec &lt;命令&gt; = 使用 shell 运行命令（此行剩余部分）</span><br><span class="line"># b, break = 在此处停止（使用 &#x27;git rebase --continue&#x27; 继续变基）</span><br><span class="line"># d, drop &lt;提交&gt; = 删除提交</span><br><span class="line"># l, label &lt;label&gt; = 为当前 HEAD 打上标记</span><br><span class="line"># t, reset &lt;label&gt; = 重置 HEAD 到该标记</span><br><span class="line"># m, merge [-C &lt;commit&gt; | -c &lt;commit&gt;] &lt;label&gt; [# &lt;oneline&gt;]</span><br><span class="line"># .       创建一个合并提交，并使用原始的合并提交说明（如果没有指定</span><br><span class="line"># .       原始提交，使用注释部分的 oneline 作为提交说明）。使用</span><br><span class="line"># .       -c &lt;提交&gt; 可以编辑提交说明。</span><br><span class="line"># u, update-ref &lt;引用&gt; = 为引用 &lt;ref&gt; 设置一个占位符，以将该引用更新为此处的新提交。</span><br><span class="line">#                       此 &lt;引用&gt; 在变基结束后更新。</span><br><span class="line">#</span><br><span class="line"># 可以对这些行重新排序，将从上至下执行。</span><br><span class="line">#</span><br><span class="line"># 如果您在这里删除一行，对应的提交将会丢失。</span><br><span class="line">#</span><br><span class="line"># 然而，如果您删除全部内容，变基操作将会终止。</span><br></pre></td></tr></table></figure><h2 id="Squash"><a href="#Squash" class="headerlink" title="Squash"></a>Squash</h2><p>在git rebase -i 中将需要压缩的提交改为s即可压缩为一个commit，然后merge到master</p><h2 id="回退版本"><a href="#回退版本" class="headerlink" title="回退版本"></a>回退版本</h2><h3 id="git-reset-与git-revert的区别"><a href="#git-reset-与git-revert的区别" class="headerlink" title="git reset 与git revert的区别"></a>git reset 与git revert的区别</h3><p>Git reset 会把回退版本之后的修改都删除掉，要从第四次修改回退到第一次修改，那么会删除中间第二、三、四次的修改。</p><p>那么如果发现第三次有错误，想要恢复第三次修改，但是要保留第四次修改呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git revert -n commitid(要恢复的第三次修改提交id)</span><br><span class="line">git commit -m &quot;恢复第三次修改&quot;</span><br></pre></td></tr></table></figure><p>git历史提交会多出来一个revert的提交记录，因为产生了一个新的commit_id。这比较适合多人开发环境，因为不能影响别人的提交。</p><p>如果是在本地的分支呢？那就可以使用git reset命令。</p><p>回退到上个版本 git reset commitid，但是修改的痕迹，即代码改动仍在你的工作区，只不过之后的commit记录(本地仓库记录)都不存在了。可以自行决定是否保留或者修改。加上–hard的话，就说明工作区里面的改动也不要了。</p><p>比如：</p><p>回退到某个912smd2提交的版本 git reset 912smd2 </p><p>回退到上个版本git reset –hard HEAD^ </p><p>回退到上上个版本git reset –hard HEAD^^</p><h2 id="Push到远程之后如何删除提交记录呢？"><a href="#Push到远程之后如何删除提交记录呢？" class="headerlink" title="Push到远程之后如何删除提交记录呢？"></a>Push到远程之后如何删除提交记录呢？</h2><p>假设有如下提交记录：<br>$ git log<br>cf8f080 (HEAD -&gt; master, origin&#x2F;master) commit 3<br>92b3abb commit 2<br>f38f353 commit 1<br>2df3c7c Initial commit</p><p>假设我们要删除92b3abb commit 2和cf8f080 commit 3 两个提交，就是说commit 2和commit 3都不要了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin +92b3abb^:git_tmp</span><br></pre></td></tr></table></figure><p>92b3abb^：表示只保留92b3abb的前一次提交，从92b3abb开始到后面的提交都不要了。<br>+：表示强制 non-fastforward push</p><h2 id="如何取消已经追踪过文件的改动呢？（reset到某个版本，git-checkout-仍无法删除）"><a href="#如何取消已经追踪过文件的改动呢？（reset到某个版本，git-checkout-仍无法删除）" class="headerlink" title="如何取消已经追踪过文件的改动呢？（reset到某个版本，git checkout .仍无法删除）"></a>如何取消已经追踪过文件的改动呢？（reset到某个版本，git checkout .仍无法删除）</h2><p><a href="https://www.cnblogs.com/lsgxeva/p/15731913.html">https://www.cnblogs.com/lsgxeva/p/15731913.html</a></p><p>git clean -n 查看将要删除的文件</p><p>git clean -f 强行删除文件</p><h2 id="如何删除commit提交记录"><a href="#如何删除commit提交记录" class="headerlink" title="如何删除commit提交记录"></a>如何删除commit提交记录</h2><p>删除 commit 的三种方法 <a href="https://www.jianshu.com/p/c9f131e22a60">https://www.jianshu.com/p/c9f131e22a60</a></p><p>git reset commitID 回到某次提交</p><p>git reset –soft 此次提交之后的修改会被退回到暂存区</p><p>git reset –hard：此次提交之后的修改不做任何保留，git status 查看工作区是没有记录的。</p><p>git reset –hard commit_id</p><h2 id="如何删除分支"><a href="#如何删除分支" class="headerlink" title="如何删除分支"></a>如何删除分支</h2><p>git branch -D branch</p><p>git push origin –delete branch</p><p>注：</p><p>git branch -d 会在删除前检查merge状态（其与上游分支或者与head）。<br>git branch -D 是git branch –delete –force的简写，它会直接删除。</p><h2 id="Submodule使用"><a href="#Submodule使用" class="headerlink" title="Submodule使用"></a>Submodule使用</h2><p>直接删除子模块的.git文件夹即可</p><p>在博客里面git clone别人的theme时，因为带有.git文件夹 导致push的时候 没有办法进行版本管理，因为也不存在子模块的版本控制，没有必要这么复杂。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.freecodecamp.org/chinese/news/gitignore-file-how-to-ignore-files-and-folders-in-git/">.gitignore参考</a></p><p><a href="https://git-scm.com/book/en/v2">git pro book</a></p><p><a href="https://www.jianshu.com/p/4c1ed3dbf421">rebase参考</a></p><p><a href="https://womanonrails.com/git-rebase-onto">rebase onto参考</a></p><p><a href="https://www.gss.com.tw/blog/%E4%BD%BF%E7%94%A8-git-rebase-interactive-%E6%A8%A1%E5%BC%8F%E6%95%B4%E7%90%86-commit">rebase -i</a></p><p><a href="https://www.gss.com.tw/blog/%E4%BD%BF%E7%94%A8-git-rebase-interactive-%E6%A8%A1%E5%BC%8F%E6%95%B4%E7%90%86-commit">rebase -i</a></p><p><a href="https://www.geeksforgeeks.org/git-squash/">squash</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://telegraph-image-5gr.pages.dev/file/8d9fb7979c933de38b530.jpg&quot; alt=&quot;tidy desk&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;git常用命令&quot;&gt;&lt;a href=&quot;#git常用命令&quot; </summary>
      
    
    
    
    <category term="git" scheme="https://alcuin1.github.io/categories/git/"/>
    
    
    <category term="git" scheme="https://alcuin1.github.io/tags/git/"/>
    
    <category term="版本管理" scheme="https://alcuin1.github.io/tags/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>2023 年度总结</title>
    <link href="https://alcuin1.github.io/2023/12/28/2023%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    <id>https://alcuin1.github.io/2023/12/28/2023%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/</id>
    <published>2023-12-28T12:10:32.000Z</published>
    <updated>2024-06-27T17:32:52.491Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2023年度总结"><a href="#2023年度总结" class="headerlink" title="2023年度总结"></a>2023年度总结</h1><p>不知不觉就又到年末了，今天是28号，再有几天就到了新的一年2024年了，这一年是自己完整地工作的第一年，感觉时间过的很快，自己已经真正的从学生变成一个打工人了，熟悉了早晚出勤的生活状态，熟悉了工作日上班，周末休息的标准两点一线生活。</p><p>感觉博客是个好东西，能留下来很多想法，所以就想自己记录一下。</p><h2 id="关键词：稳健成长"><a href="#关键词：稳健成长" class="headerlink" title="关键词：稳健成长"></a>关键词：稳健成长</h2><p>给自己一个贴切的年度关键词。这就像一本书的目录，能够让你快速想起之后的事情。</p><ul><li>健康自律</li><li>减肥成功</li><li>记录博客</li><li>直面挫折</li></ul><h2 id="1-学习成长"><a href="#1-学习成长" class="headerlink" title="1.学习成长"></a>1.学习成长</h2><p>更加自律，更加成熟，更加懂得自己想要什么。</p><h2 id="2-体验突破、娱乐休闲"><a href="#2-体验突破、娱乐休闲" class="headerlink" title="2.体验突破、娱乐休闲"></a>2.体验突破、娱乐休闲</h2><p>描述本年度在该维度下的成长或变化</p><p>第一次深圳路人局露营</p><p>第一次福田徒步运动</p><p>第一次拥有大疆无人机并炸机(bushi</p><p><img src="https://telegraph-image-5gr.pages.dev/file/41d7f39a5eabef83e9c19.png" alt="DJI"></p><p>第一次深圳大鹏户外烧烤</p><p>第一次去香港迪士尼</p><p>第一次看演唱会</p><p>第一次八个小时的自驾</p><p><img src="https://telegraph-image-5gr.pages.dev/file/2a1dd06ffe5d091f90ecf.png" alt="自驾"></p><p>第一次攀岩</p><p><img src="https://telegraph-image-5gr.pages.dev/file/96cb967602ec75c78fb64.jpg" alt="攀岩🧗🏻‍♀️"></p><p>第一次一个人做手术和拔牙 (22年11月与23年2月</p><p>第一次带老妈去广州、珠海、香港、澳门旅游，体验不同城市的感觉</p><p>第一次看司庆篮球赛</p><p>第一次工作之后再次见到多年没见老同学</p><p>第一次写博客</p><p>第一次体验正念</p><p>第一次见和女朋友一起见双方父母</p><p>第一次利用公司平台与行家大佬咨询摄影，减肥，自我成长等等</p><h2 id="3-工作事业"><a href="#3-工作事业" class="headerlink" title="3.工作事业"></a>3.工作事业</h2><p>今年在是完整工作的的第一年，逐渐适应了每天两点一线的生活，也要学会积极去面对工作中的挫折与不顺心</p><p>建立自己的职业壁垒</p><p>逐步形成个人IP</p><h2 id="4-家庭生活"><a href="#4-家庭生活" class="headerlink" title="4.家庭生活"></a>4.家庭生活</h2><p>学会如何处理亲密关系，如何更好地去爱自己在意的人。感情双方付出都是有意义的，遇到困难不能轻易放弃而是互相支持鼓励，双方一起的付出，将来是一定会有回报的。</p><p>珍惜与父母的联系，多关心爱护，心怀感恩，报答他们。同时也要理解到每一代人都是有代沟的，很多观念都是不能说服对方的，承认这一点很重要。</p><h2 id="5-身心健康"><a href="#5-身心健康" class="headerlink" title="5.身心健康"></a>5.身心健康</h2><p>今年看了看运动记录，相较于去年真的自律了很多，尤其是在后面颈椎不舒服以后，就提升了运动频率，尤其在下半年，每周坚持去运动至少两个小时，而且平时也会走路下班，健康了很多。</p><p><img src="https://telegraph-image-5gr.pages.dev/file/f736f41bde3e68ba82ec7.png" alt="健康"></p><h2 id="6-收支理财"><a href="#6-收支理财" class="headerlink" title="6.收支理财"></a>6.收支理财</h2><p>今年理财收益越有6k元，虽然不太多，但是也有在努力认真的攒钱呀</p><h2 id="7-人际社交"><a href="#7-人际社交" class="headerlink" title="7.人际社交"></a>7.人际社交</h2><p>出来深圳以后，和朋友的联系变少了很多，去年刚来到这里，还会主动去参加一些社交活动，后面发现挺累的，维持几段高质量的亲密关系真的需要付出很多精力，后面慢慢的还是更加专注在自我提升。</p><h2 id="8-反思与教训"><a href="#8-反思与教训" class="headerlink" title="8.反思与教训"></a>8.反思与教训</h2><p>工作上定期反思，积极主动，学会挑战自己的极限</p><p>生活上不要贪图便宜，经常用的一定要买好的</p><p>平时要多拍照纪念和留念每一个值得回忆的画面，保留美好的瞬间</p><h2 id="总结与期待"><a href="#总结与期待" class="headerlink" title="总结与期待"></a>总结与期待</h2><p>给自己的这一年写一段总结：</p><p>今年总体来说，平安健康，越来越有社会打工人的样子了，越来越自律，珍惜感情，注重自我提升。</p><p>而且面对挫折困难时，要抗住压力。人生不可能总是一帆风顺的，再大的困难，放到面前，也什么大不了的，学会与自己和解。</p><p>明年的flags：</p><ul><li>每周都要坚持运动2小时</li><li>制定目标，并且将其拆分为小目标，细分每个月，甚至半个月，一个一个来</li><li>每个月至少1-2篇文章输出(技术成长or其他方面</li><li>学习两个新的技能（滑雪、摄影、航拍、popping、唱歌、冲浪等等</li><li>探索至少两个新大陆（西北、北京、上海等等</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;2023年度总结&quot;&gt;&lt;a href=&quot;#2023年度总结&quot; class=&quot;headerlink&quot; title=&quot;2023年度总结&quot;&gt;&lt;/a&gt;2023年度总结&lt;/h1&gt;&lt;p&gt;不知不觉就又到年末了，今天是28号，再有几天就到了新的一年2024年了，这一年是自己完整地工</summary>
      
    
    
    
    <category term="年度总结" scheme="https://alcuin1.github.io/categories/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="summary" scheme="https://alcuin1.github.io/tags/summary/"/>
    
  </entry>
  
  <entry>
    <title>数据备份</title>
    <link href="https://alcuin1.github.io/2023/12/23/%E6%95%B0%E6%8D%AE%E5%A4%87%E4%BB%BD/"/>
    <id>https://alcuin1.github.io/2023/12/23/%E6%95%B0%E6%8D%AE%E5%A4%87%E4%BB%BD/</id>
    <published>2023-12-23T15:21:51.000Z</published>
    <updated>2024-06-27T17:32:52.492Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据备份"><a href="#数据备份" class="headerlink" title="数据备份"></a>数据备份</h1><h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1.背景"></a>1.背景</h2><p>前两天用完自己的古董机械移动硬盘时，在弹出硬件时卡顿了，然后就直接给拔掉了。今天再插上去一看，磁盘结构文件损坏。。。</p><p><img src="https://telegraph-image-5gr.pages.dev/file/0c1f087fdccbf90d0e411.png" alt="磁盘结构文件损坏"></p><p>这下完了，用了8年的移动硬盘，里面一堆数据都没了，虽然都是一些老照片资料存储啥的吧，但是也都是宝贵的记忆啊，怎么办呢？线下看看哪里能恢复数据吧</p><p>后来网上找到了个工具</p><p>DiskGenius，原名DiskMan，是一款集资料恢复、资料备份还原及磁盘分割管理三大主要功能的工具软件，以共享软件形式发行，其分割管理功能免费提供使用，但资料恢复、资料备份还原功能则需付费使用。</p><p>怀着好奇心下载了下来，扫描了一下，发现确实能找到之前的数据！！！还有之前删除掉的数据都有！！！于是赶紧充值注册软件把所有找到的文件都给拷贝出来了。由于空间不足，立马打开京东搜索移动硬盘，在选择的时候遇到了一些问题。</p><h2 id="2-特性"><a href="#2-特性" class="headerlink" title="2.特性"></a>2.特性</h2><ul><li>冷热存储。如果数据需要长期存储，不经常读写，适合机械硬盘，因为其冷存储能力很强，十年以上也不会丢失，但是SSD 大约一两年就会丢数据。现代机械硬盘大约 22 年后磁记录强度会衰减 20%（某大佬给出的数据）</li><li>可找回性。而且固态硬盘如果数据丢失基本是找不回来了，但是机械硬盘通过工具有较大概率可以找回</li><li>读写需求。如果数据频繁读写，对读写速度有要求，适合固态移动硬盘，因为其速度真的很快</li><li>预算。这个就不用说了，有钱上固态，没钱移动硬盘</li><li>物理稳定性。固态硬盘相较于机械硬盘抗震能力更强</li></ul><h2 id="3-结论"><a href="#3-结论" class="headerlink" title="3.结论"></a>3.结论</h2><p>数据安全不能依靠硬盘厂商，一定要双盘阵列容灾，一定要买支持raid1的硬盘盒，在这个前提下买大厂产品即可<br>文件低频使用的话硬盘盒足矣，高频使用或者预算充足建议买nas了，一样还是得组raid1</p><p>其次就是，硬盘如果长期保持通电状态，会产生由于电器元件和机械部件老化造成的损坏。而在断电状态下，SSD 大约一两年就会丢数据，现代机械硬盘大约 22 年后磁记录强度会衰减 20%。</p><p>所以，参考司内大佬给出合理的离线数据保存方案是：</p><p>1、用机械硬盘，断电存储<br>2、至少双重备份，重要数据至少在两块硬盘上各存一份，也可以多一个网盘备份<br>3、每隔 10 年把硬盘上的文件进行一次读取-重写入，重置磁记录强度</p><p>又或者通过冷热分层存储的方式<br>1、即时数据：存放在自己的Mac上，使用Sync thing或者rsync备份到NAS或者其他电脑<br>2、热数据：例如15-90天内的照片，视频，有可能被用于冲印或者剪辑的数据存放在NAS里面. Raid 6 或者 Raid 10来保证数据安全<br>3、冷数据：超过90天以上的数据，可以用Rclone或者腾讯云SDK备份COS和CBS.进行存储. 同时准备磁带存储阵列. 存放到磁带存储中</p><p>当然这里还有线上的保存方案，比如私有云<a href="https://www.synology.cn/">群晖Synology</a>NAS，百度云，腾讯微盘，oneDrive，googleDrive，<a href="https://cloud.tencent.com/document/product/436/53482">腾讯cos对象存储</a>，iCloud等等。</p><p>1.加密备份一份存到腾讯云COS的深度归档，来避免本地固态丢失或者损坏的情况。深度归档1TB1个月只需要10元钱，上传不需要钱。<br>2.鉴于网盘有一定被和谐风险，可以按年月或主题划分若干目录，7zip 带文件名加密选项、分卷压缩，然后上传到 微云 等，保存压缩密码。<br>3.手机自带的各种☁️，比如iCloud，华为云等等</p><h2 id="4-参考"><a href="#4-参考" class="headerlink" title="4.参考"></a>4.参考</h2><p><a href="https://mp.weixin.qq.com/s?__biz=MzA4NDk5OTgzMg==&mid=2650591412&idx=1&sn=2ba4ed0f01311c2ad3add2a3b8257f48&chksm=87d6db43b0a152555ca8209faf4ee9741eaaa335da67276b7b0105d62214ce4d7d658b1e6bd4&cur_album_id=1958397433973997575&scene=189#wechat_redirect">PKM 实证连载 Vol.01：我的家庭数据五重备份系统</a></p><p><a href="https://post.smzdm.com/p/arqv3x6q/">SSD闲置多年会丢失数据吗？如何保证固态硬盘断电后的数据安全？</a></p><p><a href="https://www.zhihu.com/question/20296398">磁带相对于硬盘存储的优势在哪？(狗头</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;数据备份&quot;&gt;&lt;a href=&quot;#数据备份&quot; class=&quot;headerlink&quot; title=&quot;数据备份&quot;&gt;&lt;/a&gt;数据备份&lt;/h1&gt;&lt;h2 id=&quot;1-背景&quot;&gt;&lt;a href=&quot;#1-背景&quot; class=&quot;headerlink&quot; title=&quot;1.背景&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="数据" scheme="https://alcuin1.github.io/categories/%E6%95%B0%E6%8D%AE/"/>
    
    
    <category term="数据" scheme="https://alcuin1.github.io/tags/%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title>图床使用</title>
    <link href="https://alcuin1.github.io/2023/12/03/%E5%9B%BE%E5%BA%8A%E4%BD%BF%E7%94%A8/"/>
    <id>https://alcuin1.github.io/2023/12/03/%E5%9B%BE%E5%BA%8A%E4%BD%BF%E7%94%A8/</id>
    <published>2023-12-03T06:09:59.000Z</published>
    <updated>2024-06-27T17:32:52.492Z</updated>
    
    <content type="html"><![CDATA[<p>先看看效果？</p><p><img src="https://2ae6fba4.telegraph-image-5gr.pages.dev/file/d8fa252ebe3ed81d76095.jpg" alt="jerek"></p><p>照片清晰度 还是不错的哈，不太清楚压缩没压缩。</p><p>b站手把手讲解：<a href="https://www.bilibili.com/video/BV13N411z7Lu">https://www.bilibili.com/video/BV13N411z7Lu</a></p><p>1.<a href="https://github.com/cf-pages/Telegraph-Image">https://github.com/cf-pages/Telegraph-Image</a></p><p>fork一个，然后看md教程即可</p><p>2.<a href="https://dash.cloudflare.com/">https://dash.cloudflare.com/</a></p><p>新建账户</p><p>3.其余按照步骤设置即可</p><p>connect github账户，新建kv，设置img_url，最后就是admin管理端的账户密码，设置好就可以使用啦，总体感觉还是很方便的！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;先看看效果？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://2ae6fba4.telegraph-image-5gr.pages.dev/file/d8fa252ebe3ed81d76095.jpg&quot; alt=&quot;jerek&quot;&gt;&lt;/p&gt;
&lt;p&gt;照片清晰度 还是不错的哈，不</summary>
      
    
    
    
    <category term="博客搭建" scheme="https://alcuin1.github.io/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
    
    <category term="blog" scheme="https://alcuin1.github.io/tags/blog/"/>
    
  </entry>
  
  <entry>
    <title>博客搭建</title>
    <link href="https://alcuin1.github.io/2023/12/01/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
    <id>https://alcuin1.github.io/2023/12/01/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</id>
    <published>2023-12-01T15:16:35.000Z</published>
    <updated>2024-07-02T15:08:02.015Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>作为一名技术工程师，出于知识积累记录自己成长方面的原因，来搭建一个属于自己的博客，这里会放一些技术相关以及阅读笔记，以及一些自己的想法等等</p><h2 id="搭建的三种途径"><a href="#搭建的三种途径" class="headerlink" title="搭建的三种途径"></a>搭建的三种途径</h2><ul><li>手写前端+后端，买一台服务器，然后部署上面</li></ul><p>优点：个性化强<br>缺点：对小白不友好</p><ul><li>通过github以及vercel进行联动部署，本地仓库写好博客以后推送到git平台自动化部署即可</li></ul><p>优点：操作简单，可以专注于博客内容<br>缺点：待补充…</p><ul><li>通过vercel与第三方组件联动，比如notion等知识管理工具</li></ul><p>优点：操作极其简单<br>缺点：待补充…</p><h2 id="搭建指南"><a href="#搭建指南" class="headerlink" title="搭建指南"></a>搭建指南</h2><p>这里主要介绍一下通过github来进行搭建的教程</p><p>安装node.js <a href="https://nodejs.org/en/download/">官网</a>  node -v检验</p><p>安装hexo，通过npm -v 检验</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli </span><br></pre></td></tr></table></figure><p>初始化博客</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init blog</span><br></pre></td></tr></table></figure><p>三连操作：新建文章+生成+预览</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo new test_my_site</span><br><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>npm install hexo -g #安装Hexo<br>npm update hexo -g #升级</p><p>命令简写<br>hexo n “我的博客” &#x3D;&#x3D; hexo new “我的博客” #新建文章<br>hexo g &#x3D;&#x3D; hexo generate #生成<br>hexo s &#x3D;&#x3D; hexo server #启动服务预览<br>hexo d &#x3D;&#x3D; hexo deploy #部署</p><p>hexo server #Hexo会监视文件变动并自动更新，无须重启服务器<br>hexo server -s #静态模式<br>hexo server -p 5000 #更改端口<br>hexo server -i 192.168.1.1 #自定义 IP<br>hexo clean #清除缓存，若是网页正常情况下可以忽略这条命令</p><p>hexo new post article 创建一个名称为 article 的文章<br>hexo new page about 创建一个名称为 about 的路由页面</p><h2 id="配置-config-yml"><a href="#配置-config-yml" class="headerlink" title="配置_config.yml"></a>配置_config.yml</h2><p>deploy:<br>type: git<br>repo: 这里填入你之前在GitHub上创建仓库的完整路径，记得加上 .git<br>branch: master</p><h2 id="安装Git部署插件"><a href="#安装Git部署插件" class="headerlink" title="安装Git部署插件"></a>安装Git部署插件</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">修改完_config.yml之后的发布四连：</span><br><span class="line">npm install hexo-deployer-git --save</span><br><span class="line">hexo clean </span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>只要前期在github配置部署好了，那么就默默等待你的文章上线吧~！！</p><h2 id="如何多端同步构建博客呢？-待补充"><a href="#如何多端同步构建博客呢？-待补充" class="headerlink" title="如何多端同步构建博客呢？(待补充)"></a>如何多端同步构建博客呢？(待补充)</h2><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://markdown.com.cn/basic-syntax/">MarkDown基本语法</a></p><p><a href="https://zhuanlan.zhihu.com/p/26625249">GitHub+Hexo 搭建个人网站详细教程</a></p><p><a href="https://hexo.io/themes/">Hexo Themes</a></p><p><a href="https://linlif.github.io/2017/05/27/Hexo%E4%BD%BF%E7%94%A8%E6%94%BB%E7%95%A5-%E6%B7%BB%E5%8A%A0%E5%88%86%E7%B1%BB%E5%8F%8A%E6%A0%87%E7%AD%BE/">Hexo使用攻略</a></p><p><a href="https://www.cnblogs.com/guoapeng/p/17627621.html">Hexo博客添加评论功能</a></p><p><a href="https://www.cnblogs.com/guoapeng/p/17627623.html">Hexo博客搜索引擎优化</a></p><p><a href="https://chrischen0405.github.io/2018/09/11/post20180911/">hexo页脚添加访客人数和总访问量</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;作为一名技术工程师，出于知识积累记录自己成长方面的原因，来搭建一个属于自己的博客，这里会放一些技术相关以及阅读笔记，以及一些自己的想法等等&lt;</summary>
      
    
    
    
    <category term="博客搭建" scheme="https://alcuin1.github.io/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
    
    <category term="blog" scheme="https://alcuin1.github.io/tags/blog/"/>
    
    <category term="hexo" scheme="https://alcuin1.github.io/tags/hexo/"/>
    
  </entry>
  
</feed>
